<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elif Tower Defense</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00e6;
            --neon-purple: #9d00ff;
            --neon-green: #00ff7b;
            --dark-bg: #0a0a12;
            --grid-color: #184654;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body, html {
            background-color: var(--dark-bg);
            color: var(--neon-blue);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100%;
            width: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-bottom: 2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
            z-index: 10;
            flex-shrink: 0;
            min-height: 50px;
        }
        
        #resources-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: clamp(14px, 2vw, 16px);
        }
        
        .resource {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .resource-value {
            font-weight: bold;
            text-shadow: 0 0 5px var(--neon-blue);
        }
        
        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        #game-canvas {
            background-color: var(--dark-bg);
            touch-action: none;
        }
        
        #side-panel {
            min-width: 220px;
            max-width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border-left: 2px solid var(--neon-purple);
            box-shadow: 0 0 10px var(--neon-purple);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            #side-panel {
                position: absolute;
                right: 0;
                height: 100%;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            #side-panel.active {
                transform: translateX(0);
            }
            
            #toggle-panel {
                display: block;
            }
        }
        
        #toggle-panel {
            display: none;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
            border: 1px solid var(--neon-purple);
            border-right: none;
            padding: 10px 5px;
            color: var(--neon-purple);
            font-size: 1.2em;
            cursor: pointer;
            z-index: 100;
        }
        
        .panel-section {
            border-bottom: 1px solid var(--neon-blue);
            padding-bottom: 15px;
            margin-bottom: 5px;
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 1em;
            margin-bottom: 10px;
            color: var(--neon-pink);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px var(--neon-pink);
        }
        
        .gem-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .gem-option {
            aspect-ratio: 1;
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .gem-option:hover, .gem-option:focus {
            box-shadow: 0 0 15px var(--neon-blue);
            transform: scale(1.05);
        }
        
        .gem-option.selected {
            border-color: var(--neon-green);
            box-shadow: 0 0 15px var(--neon-green);
        }
        
        .gem-preview {
            width: 70%;
            height: 70%;
            border-radius: 3px;
            position: relative;
        }
        
        .build-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .build-btn {
            padding: 12px 10px;
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.2s ease;
            text-align: center;
            text-transform: uppercase;
            border-radius: 4px;
        }
        
        .build-btn:hover, .build-btn:focus {
            box-shadow: 0 0 10px var(--neon-blue);
            background-color: rgba(0, 243, 255, 0.2);
        }
        
        .build-btn.active {
            border-color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }
        
        .start-btn {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }
        
        .start-btn:hover, .start-btn:focus {
            box-shadow: 0 0 10px var(--neon-green);
            background-color: rgba(0, 255, 123, 0.2);
        }
        
        #player-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-button {
            padding: 8px 15px;
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            border-radius: 4px;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .game-button:hover, .game-button:focus {
            box-shadow: 0 0 10px var(--neon-blue);
            background-color: rgba(0, 243, 255, 0.2);
        }
        
        .game-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        #start-wave-btn {
            margin-left: auto;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 18, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #start-menu {
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 80%;
            width: 500px;
            border-radius: 8px;
        }
        
        #game-title {
            font-size: clamp(1.8em, 5vw, 2.5em);
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
            margin: 0;
            text-align: center;
        }
        
        #start-game-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            min-width: 200px;
        }
        
        .wave-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2em, 5vw, 3em);
            color: var(--neon-pink);
            text-shadow: 0 0 15px var(--neon-pink);
            opacity: 0;
            animation: fadeInOut 3s ease-in-out;
            text-align: center;
            z-index: 20;
            pointer-events: none;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--neon-blue);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            max-width: 250px;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 0 10px var(--neon-blue);
            opacity: 0;
            transition: opacity 0.2s;
            color: var(--text-primary);
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            30% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes glowPulse {
            0% { filter: drop-shadow(0 0 3px var(--neon-blue)); }
            50% { filter: drop-shadow(0 0 8px var(--neon-blue)); }
            100% { filter: drop-shadow(0 0 3px var(--neon-blue)); }
        }
        
        .gem-combine-hint {
            position: absolute;
            background-color: rgba(0, 255, 123, 0.2);
            border: 2px dashed var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            z-index: 5;
            pointer-events: none;
            animation: glowPulse 1.5s infinite;
        }
        
        #recipe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.8em;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        #recipe-list::-webkit-scrollbar {
            width: 5px;
        }
        
        #recipe-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #recipe-list::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 3px;
        }
        
        .recipe-item {
            display: flex;
            align-items: center;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            cursor: help;
        }
        
        .recipe-gems {
            display: flex;
            margin-right: 5px;
        }
        
        .recipe-gem {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 3px;
        }
        
        .recipe-result {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-left: 5px;
        }
        
        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        
        .game-over-text {
            font-size: clamp(2em, 5vw, 3em);
            color: var(--neon-pink);
            text-shadow: 0 0 15px var(--neon-pink);
            text-align: center;
            margin-bottom: 20px;
        }
        
        .game-stats {
            font-size: clamp(1em, 3vw, 1.5em);
            color: var(--neon-blue);
            margin-bottom: 30px;
            text-align: center;
        }
        
        /* Accessibility enhancements */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        
        [role="button"], button {
            cursor: pointer;
        }
        
        :focus {
            outline: 2px solid var(--neon-green);
            outline-offset: 2px;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            #game-header {
                flex-direction: column;
                align-items: stretch;
                padding: 5px;
                min-height: auto;
            }
            
            #resources-container {
                flex-wrap: wrap;
                justify-content: space-between;
                margin-bottom: 5px;
            }
            
            .resource {
                font-size: 12px;
                flex: 1;
                min-width: 75px;
                justify-content: center;
            }
            
            #start-wave-btn {
                margin: 5px auto;
                width: 100%;
            }
            
            .build-btn {
                padding: 10px 5px;
                font-size: 0.8em;
            }
            
            #side-panel {
                min-width: 180px;
                padding: 10px;
            }
        }
        
        /* Help modal */
        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 18, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #help-content {
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            padding: 20px;
            max-width: 80%;
            width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 8px;
            color: var(--text-primary);
        }
        
        #help-content h2 {
            color: var(--neon-pink);
            margin-bottom: 15px;
            text-align: center;
        }
        
        #help-content h3 {
            color: var(--neon-blue);
            margin: 15px 0 5px;
        }
        
        #help-content p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        #help-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        #help-content button {
            margin-top: 15px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* Pause menu */
        #pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 18, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        
        #pause-content {
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-purple);
            box-shadow: 0 0 20px var(--neon-purple);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-radius: 8px;
            min-width: 250px;
        }
        
        .pause-title {
            color: var(--neon-purple);
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        .keyboard-controls {
            margin-top: 10px;
            display: grid;
            grid-template-columns: auto auto;
            gap: 5px 15px;
        }
        
        .keyboard-key {
            display: inline-block;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            margin-right: 5px;
        }
        
        /* Audio controls */
        #audio-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        .audio-btn {
            background-color: transparent;
            border: none;
            color: var(--neon-blue);
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            transition: all 0.2s;
        }
        
        .audio-btn:hover, .audio-btn:focus {
            background-color: rgba(0, 243, 255, 0.2);
            transform: scale(1.1);
        }
        
        .audio-btn.muted {
            color: var(--text-secondary);
            opacity: 0.7;
        }
        
        /* Difficulty selector */
        #difficulty-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .difficulty-option {
            padding: 8px 15px;
            background-color: var(--dark-bg);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s ease;
            text-align: center;
            border-radius: 4px;
        }
        
        .difficulty-option:hover, .difficulty-option:focus {
            box-shadow: 0 0 10px var(--neon-blue);
            background-color: rgba(0, 243, 255, 0.2);
        }
        
        .difficulty-option.selected {
            border-color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            background-color: rgba(0, 255, 123, 0.2);
            color: var(--neon-green);
        }
        
        /* Loading screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loading-title {
            color: var(--neon-blue);
            font-size: 2em;
            margin-bottom: 30px;
            text-shadow: 0 0 10px var(--neon-blue);
        }
        
        .loading-bar-container {
            width: 300px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px var(--neon-blue);
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background-color: var(--neon-blue);
            transition: width 0.3s;
        }
        
        .loading-text {
            color: var(--text-primary);
            margin-top: 15px;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1 class="loading-title">ELIF TOWER DEFENSE</h1>
        <div class="loading-bar-container">
            <div id="loading-bar" class="loading-bar"></div>
        </div>
        <div id="loading-text" class="loading-text">Initializing systems...</div>
    </div>

    <div id="game-container">
        <div id="overlay">
            <div id="start-menu">
                <h1 id="game-title">ELIF TOWER DEFENSE</h1>
                <div id="difficulty-selector">
                    <div class="section-title">SELECT DIFFICULTY</div>
                    <div class="difficulty-option selected" data-difficulty="normal">NORMAL</div>
                    <div class="difficulty-option" data-difficulty="hard">HARD</div>
                    <div class="difficulty-option" data-difficulty="cyber">CYBERPUNK</div>
                </div>
                <button id="start-game-btn" class="game-button">INITIALIZE GRID</button>
                <button id="help-btn" class="game-button">HOW TO PLAY</button>
            </div>
        </div>
        
        <div id="game-header">
            <div id="resources-container">
                <div class="resource" aria-live="polite">
                    <span>Lives:</span>
                    <span id="lives" class="resource-value">20</span>
                </div>
                <div class="resource" aria-live="polite">
                    <span>Gold:</span>
                    <span id="gold" class="resource-value">100</span>
                </div>
                <div class="resource" aria-live="polite">
                    <span>Wave:</span>
                    <span id="level" class="resource-value">1</span>
                </div>
                <div class="resource" aria-live="polite">
                    <span>Score:</span>
                    <span id="score" class="resource-value">0</span>
                </div>
            </div>
            <button id="start-wave-btn" class="game-button" aria-label="Start Wave">START WAVE</button>
        </div>
        
        <div id="main-area">
            <div id="canvas-container">
                <canvas id="game-canvas" tabindex="0" aria-label="Tower Defense Game Board"></canvas>
                <button id="toggle-panel" aria-label="Toggle Side Panel">☰</button>
            </div>
            
            <div id="side-panel">
                <div class="panel-section">
                    <div class="section-title">Player Stats</div>
                    <div id="player-stats">
                        <div class="stat-row">
                            <span>Maze Quality:</span>
                            <span id="maze-quality" aria-live="polite">0%</span>
                        </div>
                        <div class="stat-row">
                            <span>Special Chance:</span>
                            <span id="special-chance" aria-live="polite">5%</span>
                        </div>
                        <div class="stat-row">
                            <span>Kills:</span>
                            <span id="kill-count" aria-live="polite">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Build</div>
                    <div class="build-options">
                        <button id="build-maze" class="build-btn" aria-label="Place Maze">Place Maze (10g)</button>
                        <button id="build-gem" class="build-btn" aria-label="Place Gem">Place Gem (15g)</button>
                        <button id="next-wave" class="build-btn start-btn" aria-label="Start Next Wave">Start Wave</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Gem Inventory</div>
                    <div id="gem-inventory" class="gem-grid" aria-label="Gem Inventory">
                        <!-- Gems will be added here dynamically -->
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Recipes</div>
                    <div id="recipe-list" aria-label="Gem Recipes">
                        <!-- Recipes will be added here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div id="tooltip" class="tooltip" role="tooltip"></div>
        
        <div id="audio-controls">
            <button id="music-toggle" class="audio-btn" aria-label="Toggle Music">♫</button>
            <button id="sound-toggle" class="audio-btn" aria-label="Toggle Sound Effects">🔊</button>
        </div>
    </div>
    
    <div id="help-modal">
        <div id="help-content">
            <h2>HOW TO PLAY</h2>
            
            <h3>Objective</h3>
            <p>Defend your base against waves of enemies by building a maze and placing gems that act as towers.</p>
            
            <h3>Building</h3>
            <ul>
                <li><strong>Maze Blocks (10g):</strong> Create a path that forces enemies to take longer routes to your base.</li>
                <li><strong>Gems (15g):</strong> Place gems on maze blocks to attack enemies within range.</li>
            </ul>
            
            <h3>Gem Combinations</h3>
            <p>Combine identical gems to upgrade them, or mix different gems to create special gems with unique properties.</p>
            <p>See the Recipes panel for possible combinations.</p>
            
            <h3>Keyboard Controls</h3>
            <div class="keyboard-controls">
                <div><span class="keyboard-key">M</span> Toggle build maze mode</div>
                <div><span class="keyboard-key">G</span> Toggle build gem mode</div>
                <div><span class="keyboard-key">Space</span> Start wave</div>
                <div><span class="keyboard-key">Esc</span> Pause game</div>
                <div><span class="keyboard-key">H</span> Show help</div>
            </div>
            
            <button id="close-help" class="game-button">CLOSE</button>
        </div>
    </div>
    
    <div id="pause-menu">
        <div id="pause-content">
            <div class="pause-title">GAME PAUSED</div>
            <button id="resume-game" class="game-button">RESUME</button>
            <button id="restart-game" class="game-button">RESTART</button>
            <button id="show-help" class="game-button">HOW TO PLAY</button>
        </div>
    </div>
    
    <script>
        /*** GAME MODULE SYSTEM ***/
        
        // A simple module system for better organization
        const ElifTD = {};
        
        /*** CONFIG MODULE ***/
        ElifTD.Config = (function() {
            // Game Constants
            const GRID_SIZE = 12; // Number of cells in the grid (12x12)
            const MAX_LIVES = 20; 
            const STARTING_GOLD = 100;
            const BASE_ENEMY_SPAWN_DELAY = 800; // ms between enemy spawns
            
            // Cell Types
            const CELL_TYPES = {
                EMPTY: 0,
                MAZE: 1,
                GEM: 2,
                TOWER: 3,
                SPAWN: 4,
                BASE: 5
            };
            
            // Difficulty settings
            const DIFFICULTY = {
                NORMAL: {
                    enemyHealthMultiplier: 1.0,
                    enemySpeedMultiplier: 1.0,
                    goldMultiplier: 1.0,
                    waveSpeedMultiplier: 1.0,
                    name: "NORMAL"
                },
                HARD: {
                    enemyHealthMultiplier: 1.3,
                    enemySpeedMultiplier: 1.2,
                    goldMultiplier: 0.8,
                    waveSpeedMultiplier: 1.2,
                    name: "HARD"
                },
                CYBER: {
                    enemyHealthMultiplier: 1.6,
                    enemySpeedMultiplier: 1.4,
                    goldMultiplier: 0.7,
                    waveSpeedMultiplier: 1.5,
                    name: "CYBERPUNK"
                }
            };
            
            // Default settings
            let currentDifficulty = DIFFICULTY.NORMAL;
            
            // Game audio settings
            const AUDIO_SETTINGS = {
                musicEnabled: true,
                soundEnabled: true,
                musicVolume: 0.4,
                effectsVolume: 0.6
            };
            
            // Public interface
            return {
                GRID_SIZE,
                MAX_LIVES,
                STARTING_GOLD,
                BASE_ENEMY_SPAWN_DELAY,
                CELL_TYPES,
                DIFFICULTY,
                
                getCurrentDifficulty: function() {
                    return currentDifficulty;
                },
                
                setDifficulty: function(difficulty) {
                    if (DIFFICULTY[difficulty]) {
                        currentDifficulty = DIFFICULTY[difficulty];
                        return true;
                    }
                    return false;
                },
                
                getAudioSettings: function() {
                    return {...AUDIO_SETTINGS};
                },
                
                setAudioSettings: function(settings) {
                    if (settings.musicEnabled !== undefined) 
                        AUDIO_SETTINGS.musicEnabled = settings.musicEnabled;
                    if (settings.soundEnabled !== undefined) 
                        AUDIO_SETTINGS.soundEnabled = settings.soundEnabled;
                    if (settings.musicVolume !== undefined) 
                        AUDIO_SETTINGS.musicVolume = Math.max(0, Math.min(1, settings.musicVolume));
                    if (settings.effectsVolume !== undefined) 
                        AUDIO_SETTINGS.effectsVolume = Math.max(0, Math.min(1, settings.effectsVolume));
                }
            };
        })();
        
        /*** GEMS MODULE ***/
        ElifTD.Gems = (function() {
            // Gem Types (Basic Colors) - Range values in grid units
            const GEMS = {
                CHIPPED: {
                    RUBY: { id: 'chipped_ruby', name: 'Chipped Ruby', color: '#ff3333', damage: 10, range: 3, attackSpeed: 1.0, quality: 1, description: "Basic gem with balanced stats." },
                    SAPPHIRE: { id: 'chipped_sapphire', name: 'Chipped Sapphire', color: '#3333ff', damage: 8, range: 3.5, attackSpeed: 1.1, quality: 1, description: "Increased range but lower damage." },
                    EMERALD: { id: 'chipped_emerald', name: 'Chipped Emerald', color: '#33ff33', damage: 6, range: 4, attackSpeed: 1.3, quality: 1, description: "Fast attacks with extended range." },
                    AMETHYST: { id: 'chipped_amethyst', name: 'Chipped Amethyst', color: '#9933ff', damage: 15, range: 2.5, attackSpeed: 0.8, quality: 1, description: "High damage but shorter range." },
                    TOPAZ: { id: 'chipped_topaz', name: 'Chipped Topaz', color: '#ffff33', damage: 4, range: 4.5, attackSpeed: 1.5, quality: 1, description: "Very fast attacks with long range." },
                    OPAL: { id: 'chipped_opal', name: 'Chipped Opal', color: '#33ffff', damage: 12, range: 3.25, attackSpeed: 0.9, quality: 1, description: "Good balance of damage and speed." }
                },
                FLAWED: {
                    RUBY: { id: 'flawed_ruby', name: 'Flawed Ruby', color: '#ff3333', damage: 25, range: 3.2, attackSpeed: 1.0, quality: 2, description: "Upgraded ruby with higher damage." },
                    SAPPHIRE: { id: 'flawed_sapphire', name: 'Flawed Sapphire', color: '#3333ff', damage: 20, range: 3.7, attackSpeed: 1.1, quality: 2, description: "Upgraded sapphire with improved range." },
                    EMERALD: { id: 'flawed_emerald', name: 'Flawed Emerald', color: '#33ff33', damage: 15, range: 4.2, attackSpeed: 1.3, quality: 2, description: "Upgraded emerald with better range." },
                    AMETHYST: { id: 'flawed_amethyst', name: 'Flawed Amethyst', color: '#9933ff', damage: 35, range: 2.7, attackSpeed: 0.8, quality: 2, description: "Upgraded amethyst with higher damage." },
                    TOPAZ: { id: 'flawed_topaz', name: 'Flawed Topaz', color: '#ffff33', damage: 10, range: 4.7, attackSpeed: 1.5, quality: 2, description: "Upgraded topaz with extended range." },
                    OPAL: { id: 'flawed_opal', name: 'Flawed Opal', color: '#33ffff', damage: 30, range: 3.45, attackSpeed: 0.9, quality: 2, description: "Upgraded opal with increased damage." }
                }
            };
            
            // Special Gems (combine results)
            const SPECIAL_GEMS = {
                AQUAMARINE: { id: 'aquamarine', name: 'Aquamarine', color: '#66ffff', damage: 40, range: 4, attackSpeed: 1.2, quality: 3, recipe: ['chipped_sapphire', 'chipped_opal'], specialEffect: { type: 'slow', value: 20 }, description: "Slows enemies by 20% within range." },
                MALACHITE: { id: 'malachite', name: 'Malachite', color: '#33cc33', damage: 35, range: 4.5, attackSpeed: 1.4, quality: 3, recipe: ['chipped_emerald', 'chipped_sapphire'], specialEffect: { type: 'poison', value: 5 }, description: "Applies poison damage over time." },
                GARNET: { id: 'garnet', name: 'Garnet', color: '#cc3333', damage: 50, range: 3.5, attackSpeed: 1.0, quality: 3, recipe: ['chipped_ruby', 'chipped_amethyst'], specialEffect: { type: 'splash', value: 30 }, description: "Deals splash damage to nearby enemies." },
                CITRINE: { id: 'citrine', name: 'Citrine', color: '#ffcc33', damage: 30, range: 5, attackSpeed: 1.6, quality: 3, recipe: ['chipped_topaz', 'chipped_ruby'], specialEffect: { type: 'gold', value: 10 }, description: "Increases gold from killed enemies by 10%." },
                JADE: { id: 'jade', name: 'Jade', color: '#33cc66', damage: 45, range: 4.25, attackSpeed: 1.3, quality: 3, recipe: ['chipped_emerald', 'chipped_opal'], specialEffect: { type: 'chain', value: 3 }, description: "Attacks chain to up to 3 additional enemies." },
                PINK_DIAMOND: { id: 'pink_diamond', name: 'Pink Diamond', color: '#ff66cc', damage: 60, range: 3.75, attackSpeed: 1.1, quality: 3, recipe: ['chipped_ruby', 'chipped_opal'], specialEffect: { type: 'crit', value: 25 }, description: "25% chance to deal double damage." }
            };
            
            // Tower Recipes (also combine results)
            const TOWER_RECIPES = {
                SILVER: { id: 'silver_tower', name: 'Silver Tower', color: '#cccccc', damage: 80, range: 4.5, attackSpeed: 1.4, quality: 4, recipe: ['aquamarine', 'malachite'], specialEffect: { type: 'multi', value: 2 }, description: "Attacks two targets simultaneously." },
                GOLD: { id: 'gold_tower', name: 'Gold Tower', color: '#ffcc00', damage: 120, range: 5, attackSpeed: 1.2, quality: 5, recipe: ['garnet', 'citrine'], specialEffect: { type: 'goldAura', value: 20 }, description: "Nearby gems earn 20% more gold from kills." },
                URANIUM: { id: 'uranium_tower', name: 'Uranium Tower', color: '#66ff66', damage: 200, range: 5.5, attackSpeed: 1.0, quality: 6, recipe: ['jade', 'pink_diamond'], specialEffect: { type: 'dot', value: 40 }, description: "Applies radiation damage over time." },
                PLATINUM: { id: 'platinum_tower', name: 'Platinum Tower', color: '#e6e6e6', damage: 300, range: 6, attackSpeed: 0.8, quality: 7, recipe: ['silver_tower', 'gold_tower'], specialEffect: { type: 'global', value: 1 }, description: "Attacks all enemies on the board every 5 seconds." }
            };
            
            // Get gem by ID from any collection
            function getGemById(id) {
                // Check chipped gems
                for (const type in GEMS.CHIPPED) {
                    if (GEMS.CHIPPED[type].id === id) {
                        return {...GEMS.CHIPPED[type]};
                    }
                }
                
                // Check flawed gems
                for (const type in GEMS.FLAWED) {
                    if (GEMS.FLAWED[type].id === id) {
                        return {...GEMS.FLAWED[type]};
                    }
                }
                
                // Check special gems
                for (const type in SPECIAL_GEMS) {
                    if (SPECIAL_GEMS[type].id === id) {
                        return {...SPECIAL_GEMS[type]};
                    }
                }
                
                // Check tower gems
                for (const type in TOWER_RECIPES) {
                    if (TOWER_RECIPES[type].id === id) {
                        return {...TOWER_RECIPES[type]};
                    }
                }
                
                return null;
            }
            
            // Try to combine two gems
            function combineGems(gem1, gem2) {
                // Check special gem recipes
                for (const gemKey in SPECIAL_GEMS) {
                    const recipe = SPECIAL_GEMS[gemKey].recipe;
                    if ((gem1.id === recipe[0] && gem2.id === recipe[1]) || 
                        (gem1.id === recipe[1] && gem2.id === recipe[0])) {
                        return {...SPECIAL_GEMS[gemKey]};
                    }
                }
                
                // Check tower recipes
                for (const towerKey in TOWER_RECIPES) {
                    const recipe = TOWER_RECIPES[towerKey].recipe;
                    if ((gem1.id === recipe[0] && gem2.id === recipe[1]) || 
                        (gem1.id === recipe[1] && gem2.id === recipe[0])) {
                        return {...TOWER_RECIPES[towerKey]};
                    }
                }
                
                // Check if we have two of the same basic gems that can be upgraded
                if (gem1.id.startsWith('chipped_') && gem2.id.startsWith('chipped_')) {
                    const gem1Type = gem1.id.split('_')[1];
                    const gem2Type = gem2.id.split('_')[1];
                    
                    // If same type, upgrade to flawed
                    if (gem1Type === gem2Type && GEMS.FLAWED[gem1Type.toUpperCase()]) {
                        return {...GEMS.FLAWED[gem1Type.toUpperCase()]};
                    }
                }
                
                // No valid combination
                return null;
            }
            
            // Get a random gem type based on special chance
            function getRandomGemType(specialChance = 5) {
                // Check for special gem chance
                if (Math.random() * 100 < specialChance) {
                    // Get a random special gem
                    const specialGemTypes = Object.keys(SPECIAL_GEMS);
                    const randomType = specialGemTypes[Math.floor(Math.random() * specialGemTypes.length)];
                    return {...SPECIAL_GEMS[randomType]};
                }
                
                // Get a random basic gem type
                const gemTypes = Object.keys(GEMS.CHIPPED);
                const randomType = gemTypes[Math.floor(Math.random() * gemTypes.length)];
                
                // Return a copy of the gem type
                return {...GEMS.CHIPPED[randomType]};
            }
            
            // Get all recipes information
            function getAllRecipes() {
                const recipes = [];
                
                // Add special gem recipes
                for (const key in SPECIAL_GEMS) {
                    const gem = SPECIAL_GEMS[key];
                    recipes.push({
                        gem1: getGemById(gem.recipe[0]),
                        gem2: getGemById(gem.recipe[1]),
                        result: {...gem}
                    });
                }
                
                // Add tower recipes
                for (const key in TOWER_RECIPES) {
                    const tower = TOWER_RECIPES[key];
                    recipes.push({
                        gem1: getGemById(tower.recipe[0]),
                        gem2: getGemById(tower.recipe[1]),
                        result: {...tower}
                    });
                }
                
                // Add basic upgrade recipes
                for (const gemType in GEMS.CHIPPED) {
                    const chippedGem = GEMS.CHIPPED[gemType];
                    const flawedGem = GEMS.FLAWED[gemType];
                    
                    recipes.push({
                        gem1: {...chippedGem},
                        gem2: {...chippedGem},
                        result: {...flawedGem}
                    });
                }
                
                return recipes;
            }
            
            // Get starter gems for new game
            function getStarterGems() {
                return [
                    {...GEMS.CHIPPED.RUBY},
                    {...GEMS.CHIPPED.SAPPHIRE},
                    {...GEMS.CHIPPED.EMERALD}
                ];
            }
            
            // Public interface
            return {
                GEMS,
                SPECIAL_GEMS,
                TOWER_RECIPES,
                getGemById,
                combineGems,
                getRandomGemType,
                getAllRecipes,
                getStarterGems
            };
        })();
        
        /*** ENEMIES MODULE ***/
        ElifTD.Enemies = (function() {
            // Enemy Types
            const ENEMY_TYPES = [
                { id: 'normal', name: 'Drone', health: 50, speed: 1.0, size: 20, reward: 5, color: '#ff00e6' },
                { id: 'fast', name: 'Scout', health: 30, speed: 1.5, size: 16, reward: 7, color: '#ff5b00' },
                { id: 'tank', name: 'Guardian', health: 200, speed: 0.6, size: 24, reward: 15, color: '#c300ff' },
                { id: 'boss', name: 'Titan', health: 1000, speed: 0.4, size: 32, reward: 50, color: '#ff0000' },
                { id: 'stealth', name: 'Specter', health: 40, speed: 1.2, size: 18, reward: 10, color: '#00bfff', special: {type: 'stealth', value: 0.5} },
                { id: 'regen', name: 'Regenerator', health: 150, speed: 0.8, size: 22, reward: 12, color: '#00ff00', special: {type: 'regen', value: 2} },
                { id: 'splitter', name: 'Divider', health: 80, speed: 0.9, size: 24, reward: 8, color: '#ffff00', special: {type: 'split', value: 2} }
            ];
            
            // Wave definitions - more gradual progression with varied enemy types
            const WAVES = [
                // Early waves - introduce basic enemies
                { enemies: [{ type: 'normal', count: 10 }] },
                { enemies: [{ type: 'normal', count: 12 }, { type: 'fast', count: 5 }] },
                { enemies: [{ type: 'normal', count: 15 }, { type: 'fast', count: 8 }] },
                { enemies: [{ type: 'normal', count: 12 }, { type: 'fast', count: 8 }, { type: 'tank', count: 2 }] },
                
                // Middle waves - introduce special enemy types
                { enemies: [{ type: 'normal', count: 15 }, { type: 'fast', count: 10 }, { type: 'tank', count: 4 }] },
                { enemies: [{ type: 'normal', count: 15 }, { type: 'fast', count: 10 }, { type: 'stealth', count: 5 }] },
                { enemies: [{ type: 'normal', count: 18 }, { type: 'tank', count: 6 }, { type: 'regen', count: 3 }] },
                { enemies: [{ type: 'normal', count: 15 }, { type: 'fast', count: 15 }, { type: 'splitter', count: 5 }] },
                
                // Later waves - more enemies and combinations
                { enemies: [{ type: 'normal', count: 20 }, { type: 'fast', count: 15 }, { type: 'tank', count: 8 }, { type: 'stealth', count: 8 }] },
                { enemies: [{ type: 'normal', count: 20 }, { type: 'fast', count: 15 }, { type: 'tank', count: 10 }, { type: 'boss', count: 1 }] },
                { enemies: [{ type: 'normal', count: 25 }, { type: 'splitter', count: 10 }, { type: 'regen', count: 8 }, { type: 'stealth', count: 10 }] },
                { enemies: [{ type: 'fast', count: 25 }, { type: 'tank', count: 15 }, { type: 'boss', count: 2 }] },
                
                // End game waves - challenging combinations
                { enemies: [{ type: 'normal', count: 30 }, { type: 'fast', count: 25 }, { type: 'tank', count: 15 }, { type: 'boss', count: 3 }, { type: 'regen', count: 10 }] },
                { enemies: [{ type: 'fast', count: 35 }, { type: 'splitter', count: 15 }, { type: 'stealth', count: 15 }, { type: 'boss', count: 3 }] },
                { enemies: [{ type: 'normal', count: 40 }, { type: 'tank', count: 20 }, { type: 'regen', count: 15 }, { type: 'boss', count: 4 }] },
                
                // Final waves - epic battles
                { enemies: [{ type: 'normal', count: 50 }, { type: 'fast', count: 40 }, { type: 'tank', count: 30 }, { type: 'boss', count: 5 }, { type: 'splitter', count: 15 }] },
                { enemies: [{ type: 'normal', count: 40 }, { type: 'fast', count: 40 }, { type: 'stealth', count: 30 }, { type: 'regen', count: 20 }, { type: 'boss', count: 6 }] },
                { enemies: [{ type: 'fast', count: 50 }, { type: 'tank', count: 40 }, { type: 'splitter', count: 20 }, { type: 'boss', count: 7 }] },
                { enemies: [{ type: 'normal', count: 60 }, { type: 'fast', count: 50 }, { type: 'tank', count: 40 }, { type: 'boss', count: 10 }, { type: 'regen', count: 20 }, { type: 'stealth', count: 20 }] },
                
                // Endless waves - progressively harder (these repeat with scaling)
                { enemies: [{ type: 'normal', count: 70 }, { type: 'fast', count: 60 }, { type: 'tank', count: 50 }, { type: 'boss', count: 15 }, { type: 'regen', count: 25 }, { type: 'stealth', count: 25 }, { type: 'splitter', count: 25 }] }
            ];
            
            // Create a scaled enemy based on level and difficulty
            function createScaledEnemy(enemyType, level, difficulty) {
                const healthMultiplier = difficulty.enemyHealthMultiplier * (1 + (level - 1) * 0.15);
                const speedMultiplier = difficulty.enemySpeedMultiplier * (1 + (level - 1) * 0.05);
                const rewardMultiplier = difficulty.goldMultiplier * (1 + (level - 1) * 0.1);
                
                // Find the enemy type
                const baseEnemy = ENEMY_TYPES.find(e => e.id === enemyType) || ENEMY_TYPES[0];
                
                // Create a scaled version
                return {
                    ...baseEnemy,
                    health: Math.floor(baseEnemy.health * healthMultiplier),
                    maxHealth: Math.floor(baseEnemy.health * healthMultiplier),
                    speed: baseEnemy.speed * speedMultiplier,
                    reward: Math.floor(baseEnemy.reward * rewardMultiplier)
                };
            }
            
            // Get a specific enemy type by ID
            function getEnemyTypeById(id) {
                return ENEMY_TYPES.find(e => e.id === id) || ENEMY_TYPES[0];
            }
            
            // Get wave definition for a given level
            function getWaveDefinition(level) {
                const index = Math.min(level - 1, WAVES.length - 1);
                
                // For levels beyond defined waves, scale the final wave
                if (index === WAVES.length - 1 && level > WAVES.length) {
                    const overflow = level - WAVES.length;
                    const baseWave = {...WAVES[index]};
                    
                    // Scale enemy counts based on overflow level
                    baseWave.enemies = baseWave.enemies.map(enemy => {
                        return {
                            type: enemy.type,
                            count: Math.floor(enemy.count * (1 + overflow * 0.2))
                        };
                    });
                    
                    return baseWave;
                }
                
                return WAVES[index];
            }
            
            // Handle enemy special abilities
            function applyEnemySpecialAbilities(enemy, deltaTime) {
                if (!enemy.special) return;
                
                switch (enemy.special.type) {
                    case 'regen':
                        // Regenerate health over time
                        if (enemy.currentHealth < enemy.maxHealth) {
                            enemy.currentHealth += enemy.special.value * (deltaTime / 1000);
                            enemy.currentHealth = Math.min(enemy.currentHealth, enemy.maxHealth);
                        }
                        break;
                    // Other special abilities are handled in rendering or collision
                }
            }
            
            // Public interface
            return {
                ENEMY_TYPES,
                WAVES,
                createScaledEnemy,
                getEnemyTypeById,
                getWaveDefinition,
                applyEnemySpecialAbilities
            };
        })();
        
        /*** PATHFINDING MODULE ***/
        ElifTD.Pathfinding = (function() {
            // A* Pathfinding Algorithm
            class AStar {
                constructor(grid, start, end, cellTypes) {
                    this.grid = grid;
                    this.start = start;
                    this.end = end;
                    this.cellTypes = cellTypes;
                    this.nodes = this.createNodes();
                    this.openList = [];
                    this.closedList = [];
                }
                
                createNodes() {
                    const nodes = [];
                    
                    for (let y = 0; y < this.grid.length; y++) {
                        const row = [];
                        for (let x = 0; x < this.grid[y].length; x++) {
                            row.push({
                                x: x,
                                y: y,
                                f: 0, // total cost
                                g: 0, // cost from start
                                h: 0, // heuristic (estimated cost to end)
                                parent: null,
                                walkable: this.grid[y][x] !== this.cellTypes.MAZE // Maze pieces block path
                            });
                        }
                        nodes.push(row);
                    }
                    
                    // Make sure start and end are walkable
                    if (this.start && this.end) {
                        nodes[this.start.y][this.start.x].walkable = true;
                        nodes[this.end.y][this.end.x].walkable = true;
                    }
                    
                    return nodes;
                }
                
                getHeuristic(node) {
                    // Manhattan distance
                    return Math.abs(node.x - this.end.x) + Math.abs(node.y - this.end.y);
                }
                
                getNeighbors(node) {
                    const neighbors = [];
                    const directions = [
                        { x: 0, y: -1 }, // Up
                        { x: 1, y: 0 },  // Right
                        { x: 0, y: 1 },  // Down
                        { x: -1, y: 0 }  // Left
                    ];
                    
                    for (const dir of directions) {
                        const x = node.x + dir.x;
                        const y = node.y + dir.y;
                        
                        // Check if in bounds
                        if (x >= 0 && x < this.nodes[0].length && y >= 0 && y < this.nodes.length) {
                            neighbors.push(this.nodes[y][x]);
                        }
                    }
                    
                    return neighbors;
                }
                
                findPath() {
                    if (!this.start || !this.end) return null;
                    
                    const startNode = this.nodes[this.start.y][this.start.x];
                    const endNode = this.nodes[this.end.y][this.end.x];
                    
                    // Initialize lists
                    this.openList = [startNode];
                    this.closedList = [];
                    
                    let iterations = 0;
                    const maxIterations = 1000; // Prevent infinite loops
                    
                    while (this.openList.length > 0 && iterations < maxIterations) {
                        iterations++;
                        
                        // Sort open list by f value
                        this.openList.sort((a, b) => a.f - b.f);
                        
                        // Get node with lowest f value
                        const currentNode = this.openList.shift();
                        
                        // Add to closed list
                        this.closedList.push(currentNode);
                        
                        // Check if reached end
                        if (currentNode.x === endNode.x && currentNode.y === endNode.y) {
                            // Reconstruct path
                            const path = [];
                            let current = currentNode;
                            
                            while (current) {
                                path.unshift({ x: current.x, y: current.y });
                                current = current.parent;
                            }
                            
                            return path;
                        }
                        
                        // Check neighbors
                        const neighbors = this.getNeighbors(currentNode);
                        
                        for (const neighbor of neighbors) {
                            // Skip if in closed list or not walkable
                            if (this.closedList.includes(neighbor) || !neighbor.walkable) {
                                continue;
                            }
                            
                            // Calculate g value
                            const gScore = currentNode.g + 1;
                            
                            // Check if already in open list
                            const inOpenList = this.openList.includes(neighbor);
                            
                            if (!inOpenList || gScore < neighbor.g) {
                                neighbor.g = gScore;
                                neighbor.h = this.getHeuristic(neighbor);
                                neighbor.f = neighbor.g + neighbor.h;
                                neighbor.parent = currentNode;
                                
                                if (!inOpenList) {
                                    this.openList.push(neighbor);
                                }
                            }
                        }
                    }
                    
                    // No path found or too many iterations
                    return null;
                }
            }
            
            // Find path from start to end on a grid
            function findPath(grid, start, end, cellTypes) {
                const astar = new AStar(grid, start, end, cellTypes);
                return astar.findPath();
            }
            
            // Public interface
            return {
                findPath
            };
        })();
        
        /*** AUDIO MODULE ***/
        ElifTD.Audio = (function() {
            // Audio context
            let audioCtx;
            let audioInitialized = false;
            
            // Sound banks
            const sounds = {
                backgroundMusic: null,
                gemPlace: null,
                enemyHit: null,
                enemyDeath: null,
                waveStart: null,
                gameOver: null,
                victory: null,
                buttonClick: null,
                gemCombine: null,
                towerBuild: null
            };
            
            // Gain nodes for volume control
            let musicGain;
            let effectsGain;
            
            // Initialize audio
            function init() {
                if (audioInitialized) return;
                
                try {
                    // Create audio context
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create gain nodes
                    musicGain = audioCtx.createGain();
                    effectsGain = audioCtx.createGain();
                    
                    // Connect gain nodes to destination
                    musicGain.connect(audioCtx.destination);
                    effectsGain.connect(audioCtx.destination);
                    
                    // Set initial volumes
                    const settings = ElifTD.Config.getAudioSettings();
                    musicGain.gain.value = settings.musicVolume;
                    effectsGain.gain.value = settings.effectsVolume;
                    
                    // Load sounds
                    loadSounds();
                    
                    audioInitialized = true;
                } catch (e) {
                    console.error("Audio initialization failed:", e);
                }
            }
            
            // Load all sound assets
            function loadSounds() {
                // Synthesize and load sound effects
                sounds.gemPlace = createGemPlaceSound();
                sounds.enemyHit = createEnemyHitSound();
                sounds.enemyDeath = createEnemyDeathSound();
                sounds.waveStart = createWaveStartSound();
                sounds.gameOver = createGameOverSound();
                sounds.victory = createVictorySound();
                sounds.buttonClick = createButtonClickSound();
                sounds.gemCombine = createGemCombineSound();
                sounds.towerBuild = createTowerBuildSound();
                
                // Create background music
                sounds.backgroundMusic = createBackgroundMusic();
            }
            
            // Create procedural sound effects
            function createGemPlaceSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * 440 * t) * Math.exp(-8 * t);
                }
                
                return buffer;
            }
            
            function createEnemyHitSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * 220 * t) * Math.exp(-20 * t);
                }
                
                return buffer;
            }
            
            function createEnemyDeathSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.4, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * (300 - 200 * t) * t) * Math.exp(-5 * t);
                }
                
                return buffer;
            }
            
            function createWaveStartSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.6, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * (200 + 100 * t) * t) * Math.exp(-3 * t);
                }
                
                return buffer;
            }
            
            function createGameOverSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * (300 - 150 * t) * t) * Math.exp(-1 * t);
                }
                
                return buffer;
            }
            
            function createVictorySound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.2, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    
                    if (t < 0.3) {
                        data[i] = 0.4 * Math.sin(2 * Math.PI * 440 * t);
                    } else if (t < 0.6) {
                        data[i] = 0.4 * Math.sin(2 * Math.PI * 554 * t);
                    } else {
                        data[i] = 0.4 * Math.sin(2 * Math.PI * 659 * t) * Math.exp(-1 * (t - 0.6));
                    }
                }
                
                return buffer;
            }
            
            function createButtonClickSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.3 * Math.sin(2 * Math.PI * 880 * t) * Math.exp(-20 * t);
                }
                
                return buffer;
            }
            
            function createGemCombineSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * (500 + 200 * t) * t) * Math.exp(-4 * t);
                }
                
                return buffer;
            }
            
            function createTowerBuildSound() {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.7, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    data[i] = 0.5 * Math.sin(2 * Math.PI * (300 + 300 * t) * t) * Math.exp(-2 * t);
                }
                
                return buffer;
            }
            
            function createBackgroundMusic() {
                const buffer = audioCtx.createBuffer(2, audioCtx.sampleRate * 30, audioCtx.sampleRate);
                const leftChannel = buffer.getChannelData(0);
                const rightChannel = buffer.getChannelData(1);
                
                // Simple cyberpunk-style background
                const baseFreq = 80;
                
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    
                    // Repeating pattern every 6 seconds
                    const pattern = t % 6;
                    
                    // Simple arpeggio sequence
                    let note = baseFreq;
                    if (pattern > 1.5 && pattern < 3) note = baseFreq * 1.2;
                    if (pattern > 3 && pattern < 4.5) note = baseFreq * 1.5;
                    
                    // Add some rhythm every 0.5 seconds
                    const rhythm = Math.sin(2 * Math.PI * 2 * t) > 0 ? 0.7 : 0.3;
                    
                    // Generate sound
                    const mainOsc = 0.3 * Math.sin(2 * Math.PI * note * t);
                    const subOsc = 0.2 * Math.sin(2 * Math.PI * note/2 * t);
                    const noise = 0.05 * (Math.random() * 2 - 1);
                    
                    leftChannel[i] = (mainOsc + subOsc) * rhythm + noise;
                    // Slight variation for stereo effect
                    rightChannel[i] = (mainOsc + 0.2 * Math.sin(2 * Math.PI * (note+2) * t)) * rhythm + noise;
                }
                
                return buffer;
            }
            
            // Play a sound effect
            function playSound(soundName) {
                if (!audioInitialized || !sounds[soundName]) return;
                
                try {
                    const source = audioCtx.createBufferSource();
                    source.buffer = sounds[soundName];
                    source.connect(effectsGain);
                    source.start();
                } catch (e) {
                    console.error(`Failed to play sound ${soundName}:`, e);
                }
            }
            
            // Background music controls
            let musicSource = null;
            
            function startBackgroundMusic() {
                if (!audioInitialized || !sounds.backgroundMusic) return;
                
                try {
                    stopBackgroundMusic();
                    
                    musicSource = audioCtx.createBufferSource();
                    musicSource.buffer = sounds.backgroundMusic;
                    musicSource.connect(musicGain);
                    musicSource.loop = true;
                    musicSource.start();
                } catch (e) {
                    console.error("Failed to start background music:", e);
                }
            }
            
            function stopBackgroundMusic() {
                if (musicSource) {
                    try {
                        musicSource.stop();
                    } catch (e) {
                        // Ignore errors if already stopped
                    }
                    musicSource = null;
                }
            }
            
            // Volume controls
            function setMusicVolume(volume) {
                if (!audioInitialized) return;
                
                const newVolume = Math.max(0, Math.min(1, volume));
                musicGain.gain.value = newVolume;
                
                // Update config
                const settings = ElifTD.Config.getAudioSettings();
                settings.musicVolume = newVolume;
                ElifTD.Config.setAudioSettings(settings);
            }
            
            function setEffectsVolume(volume) {
                if (!audioInitialized) return;
                
                const newVolume = Math.max(0, Math.min(1, volume));
                effectsGain.gain.value = newVolume;
                
                // Update config
                const settings = ElifTD.Config.getAudioSettings();
                settings.effectsVolume = newVolume;
                ElifTD.Config.setAudioSettings(settings);
            }
            
            function toggleMusic() {
                const settings = ElifTD.Config.getAudioSettings();
                settings.musicEnabled = !settings.musicEnabled;
                ElifTD.Config.setAudioSettings(settings);
                
                if (settings.musicEnabled) {
                    setMusicVolume(settings.musicVolume);
                    startBackgroundMusic();
                } else {
                    setMusicVolume(0);
                    stopBackgroundMusic();
                }
                
                return settings.musicEnabled;
            }
            
            function toggleEffects() {
                const settings = ElifTD.Config.getAudioSettings();
                settings.soundEnabled = !settings.soundEnabled;
                ElifTD.Config.setAudioSettings(settings);
                
                if (settings.soundEnabled) {
                    setEffectsVolume(settings.effectsVolume);
                } else {
                    setEffectsVolume(0);
                }
                
                return settings.soundEnabled;
            }
            
            // Public interface
            return {
                init,
                playSound,
                startBackgroundMusic,
                stopBackgroundMusic,
                setMusicVolume,
                setEffectsVolume,
                toggleMusic,
                toggleEffects
            };
        })();
        
        /*** RENDER MODULE ***/
        ElifTD.Renderer = (function() {
            // Canvas and context
            let canvas, ctx;
            
            // Initialize renderer
            function init(canvasElement) {
                canvas = canvasElement;
                ctx = canvas.getContext('2d');
                return ctx !== null;
            }
            
            // Resize canvas to fit container
            function resizeCanvas(container) {
                if (!canvas) return 0;
                
                // Get available dimensions
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate size to fit in the container while keeping square aspect
                const size = Math.min(containerWidth, containerHeight);
                
                // Set canvas dimensions
                canvas.width = size;
                canvas.height = size;
                
                // Calculate cell size
                const cellSize = size / ElifTD.Config.GRID_SIZE;
                
                // Center the canvas in the container
                canvas.style.position = 'absolute';
                
                return cellSize;
            }
            
            // Clear canvas
            function clearCanvas() {
                if (ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
            
            // Draw the game grid
            function drawGrid(grid, cellSize, hoverCell, buildMode) {
                const { CELL_TYPES } = ElifTD.Config;
                
                // Draw grid with cyberpunk effect
                for (let y = 0; y < grid.length; y++) {
                    for (let x = 0; x < grid[0].length; x++) {
                        const cellType = grid[y][x];
                        
                        // Calculate cell position
                        const posX = x * cellSize;
                        const posY = y * cellSize;
                        
                        // Draw cell based on type
                        switch (cellType) {
                            case CELL_TYPES.EMPTY:
                                // Draw empty cell with grid lines
                                ctx.strokeStyle = '#184654';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(posX, posY, cellSize, cellSize);
                                break;
                                
                            case CELL_TYPES.MAZE:
                                // Draw maze piece
                                ctx.fillStyle = 'rgba(0, 243, 255, 0.1)';
                                ctx.fillRect(posX, posY, cellSize, cellSize);
                                ctx.strokeStyle = '#00f3ff';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(posX, posY, cellSize, cellSize);
                                
                                // Add some circuit patterns
                                drawCircuitPattern(posX, posY, cellSize);
                                break;
                                
                            case CELL_TYPES.SPAWN:
                                // Draw spawn point
                                ctx.fillStyle = 'rgba(0, 255, 123, 0.2)';
                                ctx.fillRect(posX, posY, cellSize, cellSize);
                                ctx.strokeStyle = '#00ff7b';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(posX, posY, cellSize, cellSize);
                                
                                // Draw spawn icon
                                ctx.fillStyle = '#00ff7b';
                                ctx.beginPath();
                                ctx.arc(posX + cellSize/2, posY + cellSize/2, cellSize * 0.3, 0, Math.PI * 2);
                                ctx.fill();
                                
                                break;
                                
                            case CELL_TYPES.BASE:
                                // Draw base point
                                ctx.fillStyle = 'rgba(255, 0, 230, 0.2)';
                                ctx.fillRect(posX, posY, cellSize, cellSize);
                                ctx.strokeStyle = '#ff00e6';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(posX, posY, cellSize, cellSize);
                                
                                // Draw base icon
                                ctx.fillStyle = '#ff00e6';
                                ctx.beginPath();
                                ctx.moveTo(posX + cellSize * 0.2, posY + cellSize * 0.2);
                                ctx.lineTo(posX + cellSize * 0.8, posY + cellSize * 0.2);
                                ctx.lineTo(posX + cellSize * 0.8, posY + cellSize * 0.8);
                                ctx.lineTo(posX + cellSize * 0.2, posY + cellSize * 0.8);
                                ctx.closePath();
                                ctx.fill();
                                
                                break;
                        }
                        
                        // Highlight hovered cell in build mode
                        if (buildMode && hoverCell && hoverCell.x === x && hoverCell.y === y) {
                            let isValid = false;
                            
                            if (buildMode === 'maze') {
                                isValid = cellType === CELL_TYPES.EMPTY;
                            } else if (buildMode === 'gem') {
                                isValid = cellType === CELL_TYPES.MAZE;
                            }
                            
                            // Draw highlight
                            ctx.strokeStyle = isValid ? '#00ff7b' : '#ff0000';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(posX, posY, cellSize, cellSize);
                            ctx.setLineDash([]);
                        }
                    }
                }
            }
            
            // Draw circuit pattern within a cell
            function drawCircuitPattern(x, y, size) {
                // Draw circuit lines with cyberpunk effect
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)';
                ctx.lineWidth = 1;
                
                // Randomize circuit pattern based on position
                const seed = (x * 100 + y) % 6;
                
                switch (seed) {
                    case 0:
                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.2, y + size * 0.5);
                        ctx.lineTo(x + size * 0.8, y + size * 0.5);
                        ctx.stroke();
                        break;
                    case 1:
                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.5, y + size * 0.2);
                        ctx.lineTo(x + size * 0.5, y + size * 0.8);
                        ctx.stroke();
                        break;
                    case 2:
                        // Corner (top-left to bottom-right)
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.2, y + size * 0.5);
                        ctx.lineTo(x + size * 0.5, y + size * 0.5);
                        ctx.lineTo(x + size * 0.5, y + size * 0.8);
                        ctx.stroke();
                        break;
                    case 3:
                        // Corner (top-right to bottom-left)
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.8, y + size * 0.5);
                        ctx.lineTo(x + size * 0.5, y + size * 0.5);
                        ctx.lineTo(x + size * 0.5, y + size * 0.8);
                        ctx.stroke();
                        break;
                    case 4:
                        // Cross
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.2, y + size * 0.5);
                        ctx.lineTo(x + size * 0.8, y + size * 0.5);
                        ctx.moveTo(x + size * 0.5, y + size * 0.2);
                        ctx.lineTo(x + size * 0.5, y + size * 0.8);
                        ctx.stroke();
                        break;
                    case 5:
                        // Node
                        ctx.beginPath();
                        ctx.arc(x + size * 0.5, y + size * 0.5, size * 0.15, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }
            }
            
            // Draw game path
            function drawPath(path, cellSize) {
                if (!path || path.length < 2) return;
                
                // Draw path with cyberpunk effect
                ctx.strokeStyle = 'rgba(0, 255, 123, 0.3)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                
                ctx.beginPath();
                ctx.moveTo(
                    path[0].x * cellSize + cellSize / 2,
                    path[0].y * cellSize + cellSize / 2
                );
                
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(
                        path[i].x * cellSize + cellSize / 2,
                        path[i].y * cellSize + cellSize / 2
                    );
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw gems on the grid
            function drawGems(gems, cellSize, hoverCell) {
                for (const gem of gems) {
                    // Draw gem
                    ctx.fillStyle = gem.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    
                    const centerX = gem.x * cellSize + cellSize / 2;
                    const centerY = gem.y * cellSize + cellSize / 2;
                    const size = cellSize * 0.4;
                    
                    // Draw gem shape (hexagon)
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = centerX + size * Math.cos(angle);
                        const y = centerY + size * Math.sin(angle);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Add glow effect
                    ctx.save();
                    ctx.shadowColor = gem.color;
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = gem.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                    
                    // Draw range indicator while hovering
                    if (hoverCell && hoverCell.x === gem.x && hoverCell.y === gem.y) {
                        ctx.strokeStyle = gem.color;
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        // Draw range circle in grid units
                        ctx.arc(centerX, centerY, gem.range * cellSize, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Draw attack line if gem is targeting an enemy
                    if (gem.target) {
                        ctx.strokeStyle = gem.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            gem.target.x * cellSize,
                            gem.target.y * cellSize
                        );
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // Draw quality indicator
                    const qualityColors = [
                        '#ffffff', // Not used, quality starts at 1
                        '#ffffff', // Common (white)
                        '#1eff00', // Uncommon (green)
                        '#0070dd', // Rare (blue)
                        '#a335ee', // Epic (purple)
                        '#ff8000', // Legendary (orange)
                        '#e6cc80', // Artifact (gold)
                        '#ff0000'  // Ultimate (red)
                    ];
                    
                    const qualityColor = qualityColors[Math.min(gem.quality, qualityColors.length - 1)];
                    
                    // Draw small quality indicator
                    ctx.fillStyle = qualityColor;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - size * 0.8, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw enemies on the grid
            function drawEnemies(enemies, cellSize) {
                for (const enemy of enemies) {
                    // Apply stealth effect if applicable
                    if (enemy.special && enemy.special.type === 'stealth') {
                        ctx.globalAlpha = enemy.special.value;
                    }
                    
                    // Draw enemy
                    ctx.fillStyle = enemy.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    
                    const centerX = enemy.x * cellSize;
                    const centerY = enemy.y * cellSize;
                    const size = enemy.size * 0.4;
                    
                    // Draw enemy shape (circuit-like design)
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Add inner circuit detail
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX - size * 0.5, centerY);
                    ctx.lineTo(centerX + size * 0.5, centerY);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size * 0.5);
                    ctx.lineTo(centerX, centerY + size * 0.5);
                    ctx.stroke();
                    
                    // Add special effect indicators if necessary
                    if (enemy.special) {
                        switch (enemy.special.type) {
                            case 'regen':
                                // Draw healing aura
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([2, 2]);
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, size * 1.2, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                break;
                            case 'split':
                                // Draw split indicator
                                ctx.fillStyle = '#ffff00';
                                ctx.beginPath();
                                ctx.arc(centerX - size * 0.4, centerY - size * 0.4, size * 0.2, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.beginPath();
                                ctx.arc(centerX + size * 0.4, centerY + size * 0.4, size * 0.2, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            // Other special abilities are rendered as needed
                        }
                    }
                    
                    // Draw health bar
                    const healthPercentage = enemy.currentHealth / enemy.maxHealth;
                    const healthBarWidth = size * 2;
                    const healthBarHeight = size * 0.3;
                    const healthBarX = centerX - size;
                    const healthBarY = centerY - size - healthBarHeight * 1.5;
                    
                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    
                    // Health
                    ctx.fillStyle = getHealthColor(healthPercentage);
                    ctx.fillRect(
                        healthBarX, 
                        healthBarY, 
                        healthBarWidth * healthPercentage, 
                        healthBarHeight
                    );
                    
                    // Reset alpha if changed
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // Get appropriate color for health bar
            function getHealthColor(percentage) {
                if (percentage > 0.6) return '#00ff7b';
                if (percentage > 0.3) return '#ffff00';
                return '#ff0000';
            }
            
            // Draw projectiles
            function drawProjectiles(projectiles, cellSize) {
                for (const projectile of projectiles) {
                    // Draw projectile
                    ctx.fillStyle = projectile.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    
                    const posX = projectile.x * cellSize;
                    const posY = projectile.y * cellSize;
                    const size = projectile.size;
                    
                    // Draw energy bolt effect
                    ctx.save();
                    ctx.shadowColor = projectile.color;
                    ctx.shadowBlur = 10;
                    
                    // Draw energy bolt
                    ctx.beginPath();
                    ctx.arc(posX, posY, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add trail effect
                    const target = projectile.targetEnemy;
                    if (target) {
                        const dx = target.x - projectile.x;
                        const dy = target.y - projectile.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const ndx = dx / length;
                        const ndy = dy / length;
                        
                        ctx.beginPath();
                        ctx.moveTo(posX, posY);
                        ctx.lineTo(
                            posX - ndx * size * 3, 
                            posY - ndy * size * 3
                        );
                        ctx.strokeStyle = projectile.color;
                        ctx.lineWidth = size / 2;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }
            
            // Draw cyberpunk background effects
            function drawCyberpunkEffects(canvasWidth, canvasHeight) {
                // Draw grid lines
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
                ctx.lineWidth = 1;
                
                // Horizontal lines
                for (let y = 0; y < canvasHeight; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvasWidth, y);
                    ctx.stroke();
                }
                
                // Vertical lines
                for (let x = 0; x < canvasWidth; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvasWidth);
                    ctx.stroke();
                }
                
                // Add some random glitch effects
                if (Math.random() < 0.02) {
                    const x = Math.random() * canvasWidth;
                    const y = Math.random() * canvasHeight;
                    const width = Math.random() * 100 + 50;
                    const height = Math.random() * 10 + 5;
                    
                    ctx.fillStyle = 'rgba(255, 0, 230, 0.2)';
                    ctx.fillRect(x, y, width, height);
                }
            }
            
            // Draw special effects (e.g. explosions, buffs)
            function drawEffects(effects, cellSize) {
                for (const effect of effects) {
                    if (effect.type === 'explosion') {
                        // Draw explosion
                        const centerX = effect.x * cellSize;
                        const centerY = effect.y * cellSize;
                        const size = effect.size * cellSize;
                        
                        // Calculate alpha based on lifetime
                        const alpha = 1 - (effect.currentTime / effect.duration);
                        
                        // Draw explosion circle
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add glow effect
                        ctx.save();
                        ctx.shadowColor = effect.color;
                        ctx.shadowBlur = 20;
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                        
                        ctx.globalAlpha = 1.0;
                    } else if (effect.type === 'buff') {
                        // Draw buff aura
                        const centerX = effect.x * cellSize;
                        const centerY = effect.y * cellSize;
                        const size = effect.size * cellSize;
                        
                        // Calculate alpha and scale based on pulse
                        const pulse = 0.2 * Math.sin(effect.currentTime * 5) + 0.8;
                        
                        ctx.globalAlpha = pulse;
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, size * pulse, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        ctx.globalAlpha = 1.0;
                    }
                    // Other effect types can be added here
                }
            }
            
            // Draw player warnings and notifications
            function drawNotifications(notifications, canvasWidth, canvasHeight) {
                for (const notification of notifications) {
                    // Calculate alpha based on lifetime
                    const alpha = Math.min(1, notification.currentTime < 0.5 ? 
                                    notification.currentTime * 2 : 
                                    (notification.duration - notification.currentTime) * 2 / notification.duration);
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = notification.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.font = `${notification.size}px 'Courier New', monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Position based on type
                    let x, y;
                    if (notification.position === 'center') {
                        x = canvasWidth / 2;
                        y = canvasHeight / 2;
                    } else if (notification.position === 'top') {
                        x = canvasWidth / 2;
                        y = canvasHeight * 0.2;
                    } else if (notification.position === 'bottom') {
                        x = canvasWidth / 2;
                        y = canvasHeight * 0.8;
                    } else {
                        // Default to the specified position
                        x = notification.x;
                        y = notification.y;
                    }
                    
                    // Add movement effect if specified
                    if (notification.movement) {
                        y += notification.movement * notification.currentTime;
                    }
                    
                    // Draw text with shadow for better visibility
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    ctx.fillText(notification.text, x, y);
                    
                    // Reset shadow and alpha
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // Draw wave announcement
            function drawWaveAnnouncement(text, progress, canvasWidth, canvasHeight) {
                // Only draw during specific progress range (0-1)
                if (progress <= 0 || progress >= 1) return;
                
                // Calculate alpha for fade in/out
                const alpha = progress < 0.3 ? progress / 0.3 : 
                              progress > 0.7 ? (1 - progress) / 0.3 : 
                              1.0;
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ff00e6';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.font = '36px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add glow effect
                ctx.shadowColor = '#ff00e6';
                ctx.shadowBlur = 15;
                
                // Draw text
                ctx.fillText(text, canvasWidth / 2, canvasHeight / 2);
                
                // Reset shadow and alpha
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
            
            // Public interface
            return {
                init,
                resizeCanvas,
                clearCanvas,
                drawGrid,
                drawPath,
                drawGems,
                drawEnemies,
                drawProjectiles,
                drawCyberpunkEffects,
                drawEffects,
                drawNotifications,
                drawWaveAnnouncement
            };
        })();
        
        /*** GAME MODULE ***/
        ElifTD.Game = (function() {
            // Game state
            const gameState = {
                grid: [],
                gems: [],
                enemies: [],
                projectiles: [],
                effects: [],
                notifications: [],
                gemInventory: [],
                buildMode: null,
                selectedGem: null,
                pendingGemPlacement: null,
                lives: ElifTD.Config.MAX_LIVES,
                gold: ElifTD.Config.STARTING_GOLD,
                level: 1,
                score: 0,
                mazeQuality: 0,
                specialChance: 5,
                killCount: 0,
                waveInProgress: false,
                gameOver: false,
                gamePaused: false,
                waveDuration: 0, // Total time for current wave
                waveElapsed: 0, // Elapsed time for current wave
                waveAnnouncement: null, // Current wave announcement
                spawnPoint: { x: 0, y: 0 },
                basePoint: { x: ElifTD.Config.GRID_SIZE - 1, y: ElifTD.Config.GRID_SIZE - 1 },
                path: [],
                cellSize: 0,
                canvas: null,
                ctx: null,
                tooltip: null,
                lastFrameTime: 0,
                hoverCell: null,
                gemCombineHint: null,
                enemiesReachedEnd: 0,
                waveCheckInterval: null,
                enemySpawnQueue: [],
                spawnTimers: [],
                nextEnemySpawn: 0,
                difficulty: null
            };
            
            // DOM elements
            let elements = {
                canvas: null,
                canvasContainer: null,
                tooltip: null,
                startWaveBtn: null,
                nextWaveBtn: null,
                buildMazeBtn: null,
                buildGemBtn: null,
                livesDisplay: null,
                goldDisplay: null,
                levelDisplay: null,
                scoreDisplay: null,
                mazeQualityDisplay: null,
                specialChanceDisplay: null,
                killCountDisplay: null,
                gemInventoryContainer: null,
                sidePanel: null,
                togglePanelBtn: null
            };
            
            // Game initialization
            function init() {
                // Get DOM elements
                elements.canvas = document.getElementById('game-canvas');
                elements.canvasContainer = document.getElementById('canvas-container');
                elements.tooltip = document.getElementById('tooltip');
                elements.startWaveBtn = document.getElementById('start-wave-btn');
                elements.nextWaveBtn = document.getElementById('next-wave');
                elements.buildMazeBtn = document.getElementById('build-maze');
                elements.buildGemBtn = document.getElementById('build-gem');
                elements.livesDisplay = document.getElementById('lives');
                elements.goldDisplay = document.getElementById('gold');
                elements.levelDisplay = document.getElementById('level');
                elements.scoreDisplay = document.getElementById('score');
                elements.mazeQualityDisplay = document.getElementById('maze-quality');
                elements.specialChanceDisplay = document.getElementById('special-chance');
                elements.killCountDisplay = document.getElementById('kill-count');
                elements.gemInventoryContainer = document.getElementById('gem-inventory');
                elements.sidePanel = document.getElementById('side-panel');
                elements.togglePanelBtn = document.getElementById('toggle-panel');
                
                // Initialize renderer
                if (!ElifTD.Renderer.init(elements.canvas)) {
                    console.error('Failed to initialize renderer');
                    return false;
                }
                
                // Set game state
                gameState.canvas = elements.canvas;
                gameState.tooltip = elements.tooltip;
                gameState.difficulty = ElifTD.Config.getCurrentDifficulty();
                
                // Resize canvas to fit container
                resizeCanvas();
                
                // Initialize the grid
                initGrid();
                
                // Add event listeners
                setupEventListeners();
                
                // Initialize audio
                ElifTD.Audio.init();
                
                // Populate recipe list
                populateRecipeList();
                
                // Update resource display
                updateResourcesDisplay();
                
                return true;
            }
            
            // Handle window resize
            function resizeCanvas() {
                gameState.cellSize = ElifTD.Renderer.resizeCanvas(elements.canvasContainer);
            }
            
            // Initialize game grid
            function initGrid() {
                const GRID_SIZE = ElifTD.Config.GRID_SIZE;
                const CELL_TYPES = ElifTD.Config.CELL_TYPES;
                
                gameState.grid = [];
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        row.push(CELL_TYPES.EMPTY);
                    }
                    gameState.grid.push(row);
                }
                
                // Set spawn point (top-left corner)
                gameState.spawnPoint = { x: 0, y: 0 };
                gameState.grid[0][0] = CELL_TYPES.SPAWN;
                
                // Set base point (bottom-right corner)
                gameState.basePoint = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
                gameState.grid[GRID_SIZE - 1][GRID_SIZE - 1] = CELL_TYPES.BASE;
            }
            
            // Setup event listeners
            function setupEventListeners() {
                // Canvas event listeners
                elements.canvas.addEventListener('click', handleCanvasClick);
                elements.canvas.addEventListener('mousemove', handleCanvasMouseMove);
                elements.canvas.addEventListener('touchmove', handleCanvasTouchMove);
                elements.canvas.addEventListener('mouseout', handleCanvasMouseOut);
                elements.canvas.addEventListener('keydown', handleKeydown);
                
                // Make canvas focusable for keyboard events
                elements.canvas.tabIndex = 0;
                
                // Button event listeners
                elements.startWaveBtn.addEventListener('click', startWave);
                elements.nextWaveBtn.addEventListener('click', startWave);
                elements.buildMazeBtn.addEventListener('click', () => setBuildMode('maze'));
                elements.buildGemBtn.addEventListener('click', () => setBuildMode('gem'));
                
                // Mobile panel toggle
                elements.togglePanelBtn.addEventListener('click', toggleSidePanel);
                
                // Window resize event
                window.addEventListener('resize', resizeCanvas);
                
                // Audio controls
                document.getElementById('music-toggle').addEventListener('click', toggleMusic);
                document.getElementById('sound-toggle').addEventListener('click', toggleSound);
                
                // Help modal controls
                document.getElementById('help-btn').addEventListener('click', showHelpModal);
                document.getElementById('close-help').addEventListener('click', hideHelpModal);
                
                // Pause menu controls
                document.getElementById('resume-game').addEventListener('click', resumeGame);
                document.getElementById('restart-game').addEventListener('click', restartGame);
                document.getElementById('show-help').addEventListener('click', () => {
                    hideModal('pause-menu');
                    showHelpModal();
                });
                
                // Difficulty selector
                const difficultyOptions = document.querySelectorAll('.difficulty-option');
                difficultyOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        // Remove selected class from all options
                        difficultyOptions.forEach(o => o.classList.remove('selected'));
                        
                        // Add selected class to clicked option
                        e.target.classList.add('selected');
                        
                        // Set difficulty
                        const difficulty = e.target.dataset.difficulty.toUpperCase();
                        ElifTD.Config.setDifficulty(difficulty);
                        gameState.difficulty = ElifTD.Config.getCurrentDifficulty();
                    });
                });
                
                // Start button
                document.getElementById('start-game-btn').addEventListener('click', startGame);
            }
            
            // Mobile side panel toggle
            function toggleSidePanel() {
                elements.sidePanel.classList.toggle('active');
            }
            
            // Audio controls
            function toggleMusic() {
                const enabled = ElifTD.Audio.toggleMusic();
                const button = document.getElementById('music-toggle');
                
                if (enabled) {
                    button.textContent = '♫';
                    button.classList.remove('muted');
                } else {
                    button.textContent = '♫';
                    button.classList.add('muted');
                }
            }
            
            function toggleSound() {
                const enabled = ElifTD.Audio.toggleEffects();
                const button = document.getElementById('sound-toggle');
                
                if (enabled) {
                    button.textContent = '🔊';
                    button.classList.remove('muted');
                } else {
                    button.textContent = '🔇';
                    button.classList.add('muted');
                }
            }
            
            // Help modal
            function showHelpModal() {
                document.getElementById('help-modal').style.display = 'flex';
                pauseGame();
            }
            
            function hideHelpModal() {
                document.getElementById('help-modal').style.display = 'none';
                resumeGame();
            }
            
            // Show modal by ID
            function showModal(id) {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.style.display = 'flex';
                }
            }
            
            // Hide modal by ID
            function hideModal(id) {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.style.display = 'none';
                }
            }
            
            // Pause game
            function pauseGame() {
                if (gameState.gameOver) return;
                
                gameState.gamePaused = true;
                showModal('pause-menu');
            }
            
            // Resume game
            function resumeGame() {
                gameState.gamePaused = false;
                hideModal('pause-menu');
                
                // Resume game loop with current time
                gameState.lastFrameTime = performance.now();
            }
            
            // Handle keyboard events
            function handleKeydown(event) {
                if (gameState.gameOver) return;
                
                switch (event.key) {
                    case 'Escape':
                        // Toggle pause menu
                        if (gameState.gamePaused) {
                            resumeGame();
                        } else {
                            pauseGame();
                        }
                        break;
                    case ' ':
                    case 'Space':
                        // Start wave
                        if (!gameState.waveInProgress && !gameState.gamePaused) {
                            startWave();
                        }
                        break;
                    case 'm':
                    case 'M':
                        // Toggle build maze mode
                        setBuildMode('maze');
                        break;
                    case 'g':
                    case 'G':
                        // Toggle build gem mode
                        setBuildMode('gem');
                        break;
                    case 'h':
                    case 'H':
                        // Show help
                        showHelpModal();
                        break;
                }
            }
            
            // Populate starter gems
            function populateStarterGems() {
                // Clear inventory
                gameState.gemInventory = ElifTD.Gems.getStarterGems();
                updateGemInventoryDisplay();
            }
            
            // Populate recipe list
            function populateRecipeList() {
                const recipeList = document.getElementById('recipe-list');
                recipeList.innerHTML = '';
                
                // Get all recipes
                const recipes = ElifTD.Gems.getAllRecipes();
                
                // Add recipes to list
                recipes.forEach(recipe => {
                    addRecipeToList(recipe.gem1, recipe.gem2, recipe.result);
                });
            }
            
            // Add recipe to list
            function addRecipeToList(gem1, gem2, result) {
                const recipeList = document.getElementById('recipe-list');
                
                const recipeItem = document.createElement('div');
                recipeItem.className = 'recipe-item';
                recipeItem.setAttribute('role', 'listitem');
                
                const recipeGems = document.createElement('div');
                recipeGems.className = 'recipe-gems';
                
                // First gem
                const gem1El = document.createElement('div');
                gem1El.className = 'recipe-gem';
                gem1El.style.backgroundColor = gem1.color;
                recipeGems.appendChild(gem1El);
                
                // Second gem
                const gem2El = document.createElement('div');
                gem2El.className = 'recipe-gem';
                gem2El.style.backgroundColor = gem2.color;
                recipeGems.appendChild(gem2El);
                
                // Arrow
                const arrow = document.createElement('span');
                arrow.textContent = '→';
                arrow.setAttribute('aria-hidden', 'true');
                
                // Result
                const resultEl = document.createElement('div');
                resultEl.className = 'recipe-result';
                resultEl.style.backgroundColor = result.color;
                
                recipeItem.appendChild(recipeGems);
                recipeItem.appendChild(arrow);
                recipeItem.appendChild(resultEl);
                
                // Add tooltip on hover
                recipeItem.addEventListener('mouseover', (e) => {
                    const tooltip = elements.tooltip;
                    tooltip.innerHTML = `${gem1.name} + ${gem2.name} = ${result.name}`;
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    tooltip.style.opacity = '1';
                });
                
                recipeItem.addEventListener('mouseout', () => {
                    elements.tooltip.style.opacity = '0';
                });
                
                // Set accessible description
                recipeItem.setAttribute('aria-label', `Recipe: ${gem1.name} plus ${gem2.name} creates ${result.name}`);
                
                recipeList.appendChild(recipeItem);
            }
            
            // Update gem inventory display
            function updateGemInventoryDisplay() {
                const inventoryEl = elements.gemInventoryContainer;
                inventoryEl.innerHTML = '';
                
                // Add gems to inventory display
                gameState.gemInventory.forEach((gem, index) => {
                    const gemEl = document.createElement('div');
                    gemEl.className = 'gem-option';
                    gemEl.dataset.gemIndex = index;
                    gemEl.setAttribute('role', 'button');
                    gemEl.setAttribute('aria-label', gem.name);
                    gemEl.tabIndex = 0; // Make focusable
                    
                    const gemPreview = document.createElement('div');
                    gemPreview.className = 'gem-preview';
                    gemPreview.style.backgroundColor = gem.color;
                    gemPreview.style.boxShadow = `0 0 10px ${gem.color}`;
                    
                    gemEl.appendChild(gemPreview);
                    
                    // Mark if selected
                    if (gameState.selectedGem === index) {
                        gemEl.classList.add('selected');
                    }
                    
                    // Add event listeners for gem selection
                    gemEl.addEventListener('click', () => selectInventoryGem(index));
                    gemEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            selectInventoryGem(index);
                            e.preventDefault();
                        }
                    });
                    gemEl.addEventListener('mouseover', (e) => showGemTooltip(e, gem));
                    gemEl.addEventListener('focus', (e) => showGemTooltip(e, gem));
                    gemEl.addEventListener('mouseout', hideTooltip);
                    gemEl.addEventListener('blur', hideTooltip);
                    
                    inventoryEl.appendChild(gemEl);
                });
                
                // If inventory is empty, show message
                if (gameState.gemInventory.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.textContent = 'No gems in inventory';
                    emptyMsg.style.gridColumn = '1 / span 3';
                    emptyMsg.style.textAlign = 'center';
                    emptyMsg.style.padding = '10px';
                    emptyMsg.style.opacity = '0.7';
                    inventoryEl.appendChild(emptyMsg);
                }
            }
            
            // Set build mode
            function setBuildMode(mode) {
                // Check if we have enough gold
                if (mode === 'maze' && gameState.gold < 10) {
                    showMessage('Not enough gold to place maze', '#ff0000');
                    playSound('buttonClick');
                    return;
                } else if (mode === 'gem' && gameState.gold < 15 && !gameState.pendingGemPlacement) {
                    showMessage('Not enough gold to place gem', '#ff0000');
                    playSound('buttonClick');
                    return;
                }
                
                // Toggle build mode
                if (gameState.buildMode === mode) {
                    gameState.buildMode = null;
                    gameState.pendingGemPlacement = null;
                } else {
                    gameState.buildMode = mode;
                    playSound('buttonClick');
                }
                
                // Update button states
                elements.buildMazeBtn.classList.toggle('active', gameState.buildMode === 'maze');
                elements.buildGemBtn.classList.toggle('active', gameState.buildMode === 'gem');
            }
            
            // Select gem from inventory
            function selectInventoryGem(index) {
                if (index >= gameState.gemInventory.length) return;
                
                const gem = gameState.gemInventory[index];
                
                // If we already have a selected gem, try to combine them
                if (gameState.selectedGem !== null && gameState.selectedGem !== index) {
                    const gem1 = gameState.gemInventory[gameState.selectedGem];
                    const gem2 = gameState.gemInventory[index];
                    
                    // Try to combine gems
                    const combinedGem = ElifTD.Gems.combineGems(gem1, gem2);
                    
                    if (combinedGem) {
                        // Replace the first gem with the combined gem
                        gameState.gemInventory[gameState.selectedGem] = combinedGem;
                        
                        // Remove the second gem
                        gameState.gemInventory.splice(index > gameState.selectedGem ? index - 1 : index, 1);
                        
                        // Deselect gem
                        gameState.selectedGem = null;
                        
                        // Update inventory display
                        updateGemInventoryDisplay();
                        
                        // Show success message
                        showMessage(`Combined into ${combinedGem.name}!`, '#00ff7b');
                        
                        // Play sound
                        playSound('gemCombine');
                    } else {
                        // Show error message
                        showMessage('Cannot combine these gems', '#ff0000');
                        gameState.selectedGem = null;
                        playSound('buttonClick');
                    }
                } else {
                    // Toggle selection
                    if (gameState.selectedGem === index) {
                        gameState.selectedGem = null;
                        
                        // If we were in gem build mode, stay in it
                        if (gameState.buildMode === 'gem') {
                            gameState.pendingGemPlacement = null;
                        }
                    } else {
                        gameState.selectedGem = index;
                        
                        // If we select a gem, automatically go into gem placement mode
                        setBuildMode('gem');
                        gameState.pendingGemPlacement = gem;
                        
                        // Play sound
                        playSound('buttonClick');
                    }
                }
                
                // Update inventory display
                updateGemInventoryDisplay();
            }
            
            // Handle canvas click
            function handleCanvasClick(event) {
                if (gameState.gameOver || gameState.gamePaused) return;
                
                // Get mouse position relative to canvas
                const rect = elements.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                handleCanvasInteraction(mouseX, mouseY);
            }
            
            // Handle touch move on canvas
            function handleCanvasTouchMove(event) {
                if (gameState.gameOver || gameState.gamePaused) return;
                
                // Prevent default touch behavior (scrolling)
                event.preventDefault();
                
                if (event.touches.length > 0) {
                    const touch = event.touches[0];
                    const rect = elements.canvas.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Update hover cell
                    updateHoverCell(touchX, touchY);
                }
            }
            
            // Handle mouse move on canvas
            function handleCanvasMouseMove(event) {
                if (gameState.gameOver || gameState.gamePaused) return;
                
                // Get mouse position relative to canvas
                const rect = elements.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                // Update hover cell
                updateHoverCell(mouseX, mouseY);
                
                // Show tooltip for gems
                if (gameState.hoverCell) {
                    const x = gameState.hoverCell.x;
                    const y = gameState.hoverCell.y;
                    
                    for (const gem of gameState.gems) {
                        if (gem.x === x && gem.y === y) {
                            showGemTooltip(event, gem);
                            return;
                        }
                    }
                }
                
                // Hide tooltip if not over a gem
                hideTooltip();
            }
            
            // Handle mouse out on canvas
            function handleCanvasMouseOut() {
                gameState.hoverCell = null;
                hideTooltip();
            }
            
            // Update hover cell based on coordinates
            function updateHoverCell(x, y) {
                // Convert to grid coordinates
                const gridX = Math.floor(x / gameState.cellSize);
                const gridY = Math.floor(y / gameState.cellSize);
                
                // Check if valid cell
                if (gridX >= 0 && gridX < ElifTD.Config.GRID_SIZE && 
                    gridY >= 0 && gridY < ElifTD.Config.GRID_SIZE) {
                    gameState.hoverCell = { x: gridX, y: gridY };
                } else {
                    gameState.hoverCell = null;
                }
            }
            
            // Handle canvas interaction
            function handleCanvasInteraction(x, y) {
                // Convert to grid coordinates
                const gridX = Math.floor(x / gameState.cellSize);
                const gridY = Math.floor(y / gameState.cellSize);
                
                // Check if valid cell
                if (gridX < 0 || gridX >= ElifTD.Config.GRID_SIZE || 
                    gridY < 0 || gridY >= ElifTD.Config.GRID_SIZE) {
                    return;
                }
                
                // Handle build mode
                if (gameState.buildMode === 'maze') {
                    placeMaze(gridX, gridY);
                } else if (gameState.buildMode === 'gem') {
                    placeGem(gridX, gridY);
                } else {
                    // If no build mode, check if clicked on a placed gem to select it
                    checkGemSelection(gridX, gridY);
                }
            }
            
            // Place maze at coordinates
            function placeMaze(x, y) {
                const CELL_TYPES = ElifTD.Config.CELL_TYPES;
                
                // Check if cell is empty
                if (gameState.grid[y][x] !== CELL_TYPES.EMPTY) {
                    showMessage('Cannot place maze here', '#ff0000');
                    return;
                }
                
                // Check if there's enough gold
                if (gameState.gold < 10) {
                    showMessage('Not enough gold', '#ff0000');
                    return;
                }
                
                // Place maze piece
                gameState.grid[y][x] = CELL_TYPES.MAZE;
                
                // Deduct gold
                gameState.gold -= 10;
                updateResourcesDisplay();
                
                // Recalculate path and maze quality
                calculatePath();
                calculateMazeQuality();
                
                // Play sound
                playSound('gemPlace');
            }
            
            // Place gem at coordinates
            function placeGem(x, y) {
                const CELL_TYPES = ElifTD.Config.CELL_TYPES;
                
                // Check if cell has a maze piece but no gem
                if (gameState.grid[y][x] !== CELL_TYPES.MAZE) {
                    showMessage('Can only place gems on maze pieces', '#ff0000');
                    return;
                }
                
                // Check if there's already a gem or tower here
                for (const gem of gameState.gems) {
                    if (gem.x === x && gem.y === y) {
                        showMessage('There is already a gem here', '#ff0000');
                        return;
                    }
                }
                
                // If we have a pending gem placement (from inventory)
                if (gameState.pendingGemPlacement) {
                    const gemData = gameState.pendingGemPlacement;
                    
                    // Create a new gem instance
                    const gem = {
                        ...gemData,
                        x: x,
                        y: y,
                        lastAttackTime: 0,
                        target: null
                    };
                    
                    // Add to gems array
                    gameState.gems.push(gem);
                    
                    // Remove from inventory
                    if (gameState.selectedGem !== null) {
                        gameState.gemInventory.splice(gameState.selectedGem, 1);
                        gameState.selectedGem = null;
                        updateGemInventoryDisplay();
                    }
                    
                    // Reset pending placement
                    gameState.pendingGemPlacement = null;
                    
                    // Check for gem combinations on the board
                    checkBoardGemCombinations(gem);
                    
                    // Play sound
                    playSound('gemPlace');
                } else {
                    // If we're just placing a new random gem
                    
                    // Check if there's enough gold
                    if (gameState.gold < 15) {
                        showMessage('Not enough gold', '#ff0000');
                        return;
                    }
                    
                    // Generate a random gem
                    const gemType = ElifTD.Gems.getRandomGemType(gameState.specialChance);
                    
                    // Create a new gem instance
                    const gem = {
                        ...gemType,
                        x: x,
                        y: y,
                        lastAttackTime: 0,
                        target: null
                    };
                    
                    // Add to gems array
                    gameState.gems.push(gem);
                    
                    // Deduct gold
                    gameState.gold -= 15;
                    updateResourcesDisplay();
                    
                    // Check for gem combinations on the board
                    checkBoardGemCombinations(gem);
                    
                    // Play sound
                    playSound('gemPlace');
                }
                
                // Exit build mode
                gameState.buildMode = null;
                elements.buildMazeBtn.classList.remove('active');
                elements.buildGemBtn.classList.remove('active');
            }
            
            // Check for gem selection
            function checkGemSelection(x, y) {
                // Check if there's a gem at this position
                for (const gem of gameState.gems) {
                    if (gem.x === x && gem.y === y) {
                        // Show gem details
                        showGemDetails(gem);
                        return;
                    }
                }
            }
            
            // Show gem details (modal)
            function showGemDetails(gem) {
                // Create a temporary tooltip in the center of the screen
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.style.left = '50%';
                tooltip.style.top = '50%';
                tooltip.style.transform = 'translate(-50%, -50%)';
                tooltip.style.maxWidth = '300px';
                tooltip.style.padding = '15px';
                tooltip.style.opacity = '1';
                tooltip.style.pointerEvents = 'auto';
                tooltip.setAttribute('role', 'dialog');
                tooltip.setAttribute('aria-labelledby', 'gem-details-title');
                
                // Add gem details
                tooltip.innerHTML = `
                    <h3 id="gem-details-title" style="color: ${gem.color}; margin-bottom: 10px;">${gem.name}</h3>
                    <div style="margin-bottom: 5px;">Damage: ${gem.damage}</div>
                    <div style="margin-bottom: 5px;">Range: ${gem.range} cells</div>
                    <div style="margin-bottom: 5px;">Attack Speed: ${gem.attackSpeed.toFixed(1)}/s</div>
                    <div style="margin-bottom: 5px;">Quality: ${gem.quality}</div>
                    ${gem.description ? `<div style="margin-bottom: 10px;">${gem.description}</div>` : ''}
                    ${gem.specialEffect ? `<div style="margin-bottom: 10px;"><strong>Special:</strong> ${gem.specialEffect.type} (${gem.specialEffect.value})</div>` : ''}
                    <button id="collect-gem" style="
                        background-color: var(--dark-bg);
                        border: 1px solid var(--neon-blue);
                        color: var(--neon-blue);
                        padding: 5px 10px;
                        margin-top: 10px;
                        cursor: pointer;
                    ">Collect Gem</button>
                `;
                
                // Add to game container
                document.getElementById('game-container').appendChild(tooltip);
                
                // Add event listener to close tooltip
                tooltip.addEventListener('click', (e) => {
                    if (e.target.id === 'collect-gem') {
                        collectGem(gem);
                    }
                    tooltip.remove();
                });
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (document.body.contains(tooltip)) {
                        tooltip.remove();
                    }
                }, 5000);
                
                // Play sound
                playSound('buttonClick');
            }
            
            // Collect gem from the board
            function collectGem(gem) {
                // Add gem to inventory
                gameState.gemInventory.push({...gem});
                
                // Remove gem from board
                const index = gameState.gems.findIndex(g => g.x === gem.x && g.y === gem.y);
                if (index !== -1) {
                    gameState.gems.splice(index, 1);
                }
                
                // Update inventory display
                updateGemInventoryDisplay();
                
                // Show message
                showMessage(`Collected ${gem.name}`, '#00ff7b');
                
                // Play sound
                playSound('gemCombine');
            }
            
            // Check for gem combinations on the board
            function checkBoardGemCombinations(newGem) {
                // Check for adjacent gems that can be combined
                const adjacentCells = [
                    { x: newGem.x - 1, y: newGem.y },
                    { x: newGem.x + 1, y: newGem.y },
                    { x: newGem.x, y: newGem.y - 1 },
                    { x: newGem.x, y: newGem.y + 1 }
                ];
                
                // Filter out invalid cells
                const validAdjacentCells = adjacentCells.filter(cell => 
                    cell.x >= 0 && cell.x < ElifTD.Config.GRID_SIZE && 
                    cell.y >= 0 && cell.y < ElifTD.Config.GRID_SIZE
                );
                
                // Check each adjacent cell for gems
                for (const cell of validAdjacentCells) {
                    // Find gem at this position
                    const adjacentGem = gameState.gems.find(gem => gem.x === cell.x && gem.y === cell.y);
                    
                    if (adjacentGem) {
                        // Try to combine gems
                        const combinedGem = ElifTD.Gems.combineGems(newGem, adjacentGem);
                        
                        if (combinedGem) {
                            // Show combine hint
                            showGemCombineHint(newGem, adjacentGem);
                            return;
                        }
                    }
                }
            }
            
            // Show hint that gems can be combined
            function showGemCombineHint(gem1, gem2) {
                // Remove existing hint
                removeGemCombineHint();
                
                // Calculate hint dimensions
                const minX = Math.min(gem1.x, gem2.x);
                const minY = Math.min(gem1.y, gem2.y);
                const maxX = Math.max(gem1.x, gem2.x);
                const maxY = Math.max(gem1.y, gem2.y);
                
                // Create hint element
                const hint = document.createElement('div');
                hint.className = 'gem-combine-hint';
                hint.setAttribute('aria-hidden', 'true');
                
                // Position hint on the canvas
                const canvasRect = elements.canvas.getBoundingClientRect();
                const left = canvasRect.left + minX * gameState.cellSize;
                const top = canvasRect.top + minY * gameState.cellSize;
                const width = (maxX - minX + 1) * gameState.cellSize;
                const height = (maxY - minY + 1) * gameState.cellSize;
                
                hint.style.left = `${left}px`;
                hint.style.top = `${top}px`;
                hint.style.width = `${width}px`;
                hint.style.height = `${height}px`;
                
                // Add to canvas container
                elements.canvasContainer.appendChild(hint);
                
                // Save reference to hint
                gameState.gemCombineHint = hint;
                
                // Auto-remove after 3 seconds
                setTimeout(removeGemCombineHint, 3000);
            }
            
            // Remove gem combine hint
            function removeGemCombineHint() {
                if (gameState.gemCombineHint) {
                    gameState.gemCombineHint.remove();
                    gameState.gemCombineHint = null;
                }
            }
            
            // Show gem tooltip
            function showGemTooltip(event, gem) {
                const tooltip = elements.tooltip;
                
                // Set tooltip content
                tooltip.innerHTML = `
                    <div style="color: ${gem.color}; font-weight: bold; margin-bottom: 4px;">${gem.name}</div>
                    <div>DMG: ${gem.damage} | RNG: ${gem.range}</div>
                    <div>SPD: ${gem.attackSpeed.toFixed(1)}/s | Q: ${gem.quality}</div>
                    ${gem.specialEffect ? `<div>Special: ${gem.specialEffect.type}</div>` : ''}
                `;
                
                // Position tooltip
                if (event.clientX) {
                    // Mouse event
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                } else {
                    // Focus event - position near the element
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style.left = `${rect.right + 10}px`;
                    tooltip.style.top = `${rect.top}px`;
                }
                
                tooltip.style.opacity = '1';
            }
            
            // Hide tooltip
            function hideTooltip() {
                elements.tooltip.style.opacity = '0';
            }
            
            // Calculate path using A* algorithm
            function calculatePath() {
                // Uses A* algorithm to find path from spawn to base
                const path = ElifTD.Pathfinding.findPath(
                    gameState.grid, 
                    gameState.spawnPoint,
                    gameState.basePoint,
                    ElifTD.Config.CELL_TYPES
                );
                
                if (path && path.length > 0) {
                    gameState.path = path;
                    return true;
                } else {
                    // No valid path found
                    showMessage('No valid path to base - fix your maze', '#ff0000');
                    return false;
                }
            }
            
            // Calculate maze quality based on path length
            function calculateMazeQuality() {
                // Maze quality is based on path length
                if (!gameState.path || gameState.path.length === 0) return 0;
                
                // Calculate direct distance
                const directDistance = Math.sqrt(
                    Math.pow(gameState.basePoint.x - gameState.spawnPoint.x, 2) +
                    Math.pow(gameState.basePoint.y - gameState.spawnPoint.y, 2)
                );
                
                // Calculate path length
                const pathLength = gameState.path.length;
                
                // Quality is the ratio of path length to direct distance
                const quality = Math.min(100, Math.floor((pathLength / directDistance) * 20));
                
                gameState.mazeQuality = quality;
                
                // Update special chance based on quality
                gameState.specialChance = 5 + Math.floor(quality / 10);
                
                // Update UI
                updateResourcesDisplay();
                
                return quality;
            }
            
            // Start the game
            function startGame() {
                // Hide the overlay
                document.getElementById('overlay').style.display = 'none';
                
                // Reset game state
                resetGameState();
                
                // Generate initial path
                calculatePath();
                
                // Update resource display
                updateResourcesDisplay();
                
                // Start background music
                ElifTD.Audio.startBackgroundMusic();
                
                // Fill gem inventory with starter gems
                populateStarterGems();
                
                // Start the game loop with current time
                gameState.lastFrameTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
            
            // Reset game state for a new game
            function resetGameState() {
                gameState.gems = [];
                gameState.enemies = [];
                gameState.projectiles = [];
                gameState.effects = [];
                gameState.notifications = [];
                gameState.gemInventory = [];
                gameState.lives = ElifTD.Config.MAX_LIVES;
                gameState.gold = ElifTD.Config.STARTING_GOLD;
                gameState.level = 1;
                gameState.score = 0;
                gameState.mazeQuality = 0;
                gameState.specialChance = 5;
                gameState.killCount = 0;
                gameState.waveInProgress = false;
                gameState.gameOver = false;
                gameState.gamePaused = false;
                gameState.enemiesReachedEnd = 0;
                gameState.spawnTimers = [];
                gameState.difficulty = ElifTD.Config.getCurrentDifficulty();
                
                // Clear build mode
                gameState.buildMode = null;
                gameState.selectedGem = null;
                gameState.pendingGemPlacement = null;
                
                // Reset grid
                initGrid();
                
                // Update UI
                elements.buildMazeBtn.classList.remove('active');
                elements.buildGemBtn.classList.remove('active');
            }
            
            // Start wave of enemies
            function startWave() {
                if (gameState.waveInProgress || gameState.gameOver || gameState.gamePaused) return;
                
                // Ensure there's a valid path
                if (!gameState.path || gameState.path.length < 2) {
                    showMessage('No valid path to base - fix your maze', '#ff0000');
                    return;
                }
                
                gameState.waveInProgress = true;
                
                // Show wave announcement
                gameState.waveAnnouncement = {
                    text: `WAVE ${gameState.level}`,
                    progress: 0,
                    duration: 3  // seconds
                };
                
                // Play sound
                playSound('waveStart');
                
                // Get current wave definition
                const wave = ElifTD.Enemies.getWaveDefinition(gameState.level);
                
                // Clear any existing spawn queue
                gameState.enemySpawnQueue = [];
                
                // Prepare enemy spawn queue with calculated delays
                let spawnDelay = 1000; // Start after 1 second
                const waveSpeedMultiplier = gameState.difficulty.waveSpeedMultiplier;
                
                wave.enemies.forEach(enemyGroup => {
                    for (let i = 0; i < enemyGroup.count; i++) {
                        // Create scaled enemy
                        const enemy = ElifTD.Enemies.createScaledEnemy(
                            enemyGroup.type, 
                            gameState.level, 
                            gameState.difficulty
                        );
                        
                        // Add to spawn queue with delay
                        gameState.enemySpawnQueue.push({
                            enemy: enemy,
                            delay: spawnDelay
                        });
                        
                        // Increment delay for next spawn (spaced based on enemy type and wave speed)
                        spawnDelay += (400 / enemy.speed) / waveSpeedMultiplier;
                    }
                });
                
                // Calculate total wave duration (last enemy spawn + time to reach end)
                const pathLength = gameState.path.length;
                const estimatedTraversalTime = pathLength * 1000 / 0.5; // Assuming base movement speed
                gameState.waveDuration = spawnDelay + estimatedTraversalTime;
                gameState.waveElapsed = 0;
                
                // Update UI
                elements.startWaveBtn.disabled = true;
                elements.nextWaveBtn.disabled = true;
            }
            
            // Spawn enemy at spawn point
            function spawnEnemy(enemy) {
                enemy.x = gameState.spawnPoint.x;
                enemy.y = gameState.spawnPoint.y;
                enemy.currentHealth = enemy.health;
                enemy.maxHealth = enemy.health;
                enemy.pathIndex = 0;
                enemy.pathProgress = 0;
                enemy.effects = []; // For status effects like slow, poison, etc.
                
                // Add to enemies array
                gameState.enemies.push(enemy);
                
                // Play sound (but not for every enemy to avoid sound overload)
                if (gameState.enemies.length % 5 === 0) {
                    playSound('enemyHit', 0.3);
                }
            }
            
            // Check if wave is complete
            function checkWaveEnd() {
                // Wave is complete when all enemies are gone and spawn queue is empty
                if (gameState.enemies.length === 0 && gameState.enemySpawnQueue.length === 0) {
                    gameState.waveInProgress = false;
                    
                    // Increase level
                    gameState.level++;
                    
                    // Award gold for completing wave
                    const bonus = Math.floor(25 + gameState.level * 5);
                    gameState.gold += bonus;
                    
                    // Update UI
                    updateResourcesDisplay();
                    elements.startWaveBtn.disabled = false;
                    elements.nextWaveBtn.disabled = false;
                    
                    // Show message
                    showMessage(`Wave Complete! +${bonus} Gold`, '#00ff7b');
                    
                    // Play victory sound
                    playSound('victory');
                    
                    return true;
                }
                
                return false;
            }
            
            // Update enemies
            function updateEnemies(deltaTime) {
                const secondsPassed = deltaTime / 1000;
                
                // Process spawn queue
                if (gameState.enemySpawnQueue.length > 0) {
                    // Update delays
                    for (let i = 0; i < gameState.enemySpawnQueue.length; i++) {
                        gameState.enemySpawnQueue[i].delay -= deltaTime;
                    }
                    
                    // Spawn enemies with elapsed delay
                    while (gameState.enemySpawnQueue.length > 0 && 
                           gameState.enemySpawnQueue[0].delay <= 0) {
                        const enemyData = gameState.enemySpawnQueue.shift();
                        spawnEnemy(enemyData.enemy);
                    }
                }
                
                // Update existing enemies
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    
                    // Apply special abilities
                    if (enemy.special) {
                        ElifTD.Enemies.applyEnemySpecialAbilities(enemy, deltaTime);
                    }
                    
                    // Apply status effects
                    updateEnemyStatusEffects(enemy, deltaTime);
                    
                    // Move enemy along path
                    moveEnemyAlongPath(enemy, secondsPassed);
                    
                    // Check if enemy is dead
                    if (enemy.currentHealth <= 0) {
                        // Calculate gold reward
                        let goldReward = enemy.reward;
                        
                        // Check for gold bonus from gems
                        for (const gem of gameState.gems) {
                            if (gem.specialEffect && gem.specialEffect.type === 'gold') {
                                const distance = Math.sqrt(
                                    Math.pow((gem.x + 0.5) - enemy.x, 2) + 
                                    Math.pow((gem.y + 0.5) - enemy.y, 2)
                                );
                                
                                if (distance <= gem.range) {
                                    goldReward = Math.floor(goldReward * (1 + gem.specialEffect.value / 100));
                                }
                            }
                        }
                        
                        // Check for gold aura from towers
                        for (const gem of gameState.gems) {
                            if (gem.specialEffect && gem.specialEffect.type === 'goldAura') {
                                // Find all gems in range of the gold aura
                                for (const targetGem of gameState.gems) {
                                    if (targetGem !== gem) {
                                        const distance = Math.sqrt(
                                            Math.pow(gem.x - targetGem.x, 2) + 
                                            Math.pow(gem.y - targetGem.y, 2)
                                        );
                                        
                                        if (distance <= gem.range) {
                                            goldReward = Math.floor(goldReward * (1 + gem.specialEffect.value / 100));
                                            break; // Only apply once
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Remove enemy and give gold
                        gameState.enemies.splice(i, 1);
                        gameState.gold += goldReward;
                        gameState.score += goldReward;
                        gameState.killCount++;
                        
                        // Create death effect
                        addEffect({
                            type: 'explosion',
                            x: enemy.x,
                            y: enemy.y,
                            size: enemy.size / 50,
                            color: enemy.color,
                            duration: 0.5,
                            currentTime: 0
                        });
                        
                        // Check for splitter enemy (create smaller enemies on death)
                        if (enemy.special && enemy.special.type === 'split' && enemy.maxHealth > 20) {
                            // Create smaller versions
                            for (let j = 0; j < enemy.special.value; j++) {
                                const smallEnemy = {
                                    ...enemy,
                                    health: Math.floor(enemy.maxHealth / 3),
                                    maxHealth: Math.floor(enemy.maxHealth / 3),
                                    size: enemy.size * 0.7,
                                    reward: Math.floor(enemy.reward / 2),
                                    // Randomize position slightly
                                    x: enemy.x + (Math.random() * 0.4 - 0.2),
                                    y: enemy.y + (Math.random() * 0.4 - 0.2),
                                    pathIndex: enemy.pathIndex,
                                    pathProgress: enemy.pathProgress + (Math.random() * 0.2 - 0.1)
                                };
                                // Ensure pathProgress is valid
                                smallEnemy.pathProgress = Math.max(0, Math.min(1, smallEnemy.pathProgress));
                                gameState.enemies.push(smallEnemy);
                            }
                        }
                        
                        updateResourcesDisplay();
                        
                        // Play death sound (but not for every enemy)
                        if (Math.random() < 0.3) {
                            playSound('enemyDeath', 0.4);
                        }
                    }
                }
                
                // Check if wave is complete
                if (gameState.enemies.length === 0 && gameState.enemySpawnQueue.length === 0 && 
                    gameState.waveInProgress) {
                    checkWaveEnd();
                }
            }
            
            // Update enemy status effects
            function updateEnemyStatusEffects(enemy, deltaTime) {
                if (!enemy.effects) enemy.effects = [];
                
                // Process each effect
                for (let i = enemy.effects.length - 1; i >= 0; i--) {
                    const effect = enemy.effects[i];
                    
                    // Update effect duration
                    effect.duration -= deltaTime / 1000;
                    
                    // Apply effect based on type
                    switch (effect.type) {
                        case 'slow':
                            // Effect applied in movement calculation
                            break;
                        case 'poison':
                            // Apply damage over time
                            enemy.currentHealth -= effect.value * (deltaTime / 1000);
                            break;
                        case 'dot':
                            // Apply damage over time (radiation)
                            enemy.currentHealth -= effect.value * (deltaTime / 1000);
                            break;
                    }
                    
                    // Remove expired effects
                    if (effect.duration <= 0) {
                        enemy.effects.splice(i, 1);
                    }
                }
            }
            
            // Move enemy along path
            function moveEnemyAlongPath(enemy, deltaTime) {
                // Skip if invalid path or already at the end
                if (!gameState.path || gameState.path.length < 2 || enemy.pathIndex >= gameState.path.length - 1) {
                    return;
                }
                
                // Apply slow effects
                let speedMultiplier = 1.0;
                if (enemy.effects) {
                    for (const effect of enemy.effects) {
                        if (effect.type === 'slow') {
                            speedMultiplier *= (1 - effect.value / 100);
                        }
                    }
                }
                
                // Calculate how far along the current path segment the enemy should move
                // Use a base speed value that works well with the maze scale
                const baseSpeed = 0.5; // Base cells per second
                const speed = baseSpeed * enemy.speed * speedMultiplier * deltaTime;
                enemy.pathProgress += speed;
                
                // If reached the next waypoint, move to the next segment
                if (enemy.pathProgress >= 1) {
                    enemy.pathIndex++;
                    enemy.pathProgress = 0;
                    
                    // If reached the end of the path, deduct a life and remove enemy
                    if (enemy.pathIndex >= gameState.path.length - 1) {
                        // Set position to the end point for visual clarity
                        const lastPoint = gameState.path[gameState.path.length - 1];
                        enemy.x = lastPoint.x;
                        enemy.y = lastPoint.y;
                        
                        // Deduct a life
                        gameState.lives--;
                        gameState.enemiesReachedEnd++;
                        updateResourcesDisplay();
                        
                        // Remove the enemy
                        const index = gameState.enemies.indexOf(enemy);
                        if (index !== -1) {
                            gameState.enemies.splice(index, 1);
                        }
                        
                        // Check for game over
                        if (gameState.lives <= 0) {
                            gameOver();
                        }
                        
                        return;
                    }
                }
                
                // Interpolate position between current and next waypoint
                const currentWaypoint = gameState.path[enemy.pathIndex];
                const nextWaypoint = gameState.path[enemy.pathIndex + 1];
                
                enemy.x = currentWaypoint.x + (nextWaypoint.x - currentWaypoint.x) * enemy.pathProgress;
                enemy.y = currentWaypoint.y + (nextWaypoint.y - currentWaypoint.y) * enemy.pathProgress;
            }
            
            // Update gems (towers)
            function updateGems(deltaTime) {
                const currentTime = Date.now();
                
                for (const gem of gameState.gems) {
                    // Calculate attack cooldown in milliseconds
                    const attackCooldown = 1000 / gem.attackSpeed;
                    
                    // Check if gem can attack
                    if (currentTime - gem.lastAttackTime >= attackCooldown) {
                        // Special handling for global attack gems
                        if (gem.specialEffect && gem.specialEffect.type === 'global' && 
                            (currentTime - gem.lastGlobalAttack || 0) >= 5000) { // Every 5 seconds
                            
                            // Attack all enemies on the board
                            if (gameState.enemies.length > 0) {
                                gem.lastGlobalAttack = currentTime;
                                gem.lastAttackTime = currentTime;
                                
                                // Create visual effect
                                addEffect({
                                    type: 'explosion',
                                    x: gem.x + 0.5,
                                    y: gem.y + 0.5,
                                    size: 10,
                                    color: gem.color,
                                    duration: 1,
                                    currentTime: 0
                                });
                                
                                // Apply damage to all enemies
                                for (const enemy of gameState.enemies) {
                                    enemy.currentHealth -= gem.damage;
                                    
                                    // Create mini explosion at each enemy
                                    addEffect({
                                        type: 'explosion',
                                        x: enemy.x,
                                        y: enemy.y,
                                        size: 0.3,
                                        color: gem.color,
                                        duration: 0.5,
                                        currentTime: 0
                                    });
                                }
                                
                                // Play sound
                                playSound('enemyHit', 0.6);
                            }
                            continue;
                        }
                        
                        // Find enemies in range
                        let targets = [];
                        let targetCount = 1;
                        
                        // Check for multi-target special effect
                        if (gem.specialEffect && gem.specialEffect.type === 'multi') {
                            targetCount = gem.specialEffect.value;
                        } else if (gem.specialEffect && gem.specialEffect.type === 'chain') {
                            targetCount = gem.specialEffect.value;
                        }
                        
                        // Find valid targets
                        for (const enemy of gameState.enemies) {
                            const distance = Math.sqrt(
                                Math.pow((gem.x + 0.5) - enemy.x, 2) + 
                                Math.pow((gem.y + 0.5) - enemy.y, 2)
                            );
                            
                            // Check if enemy is in range
                            // Apply detection penalty for stealth enemies
                            let effectiveRange = gem.range;
                            if (enemy.special && enemy.special.type === 'stealth') {
                                effectiveRange *= (1 - enemy.special.value);
                            }
                            
                            if (distance <= effectiveRange) {
                                targets.push({
                                    enemy: enemy,
                                    distance: distance
                                });
                            }
                        }
                        
                        // Sort targets by distance
                        targets.sort((a, b) => a.distance - b.distance);
                        
                        // Limit to target count
                        targets = targets.slice(0, targetCount);
                        
                        // Attack targets if any found
                        if (targets.length > 0) {
                            gem.target = targets[0].enemy;
                            gem.lastAttackTime = currentTime;
                            
                            // Create projectiles for all targets
                            for (let i = 0; i < targets.length; i++) {
                                if (i === 0 || gem.specialEffect?.type !== 'chain') {
                                    // Direct projectile from gem
                                    createProjectile(gem, targets[i].enemy);
                                } else {
                                    // Chain projectile from previous target
                                    const prevEnemy = targets[i-1].enemy;
                                    createChainProjectile(prevEnemy, targets[i].enemy, gem);
                                }
                            }
                        } else {
                            gem.target = null;
                        }
                    }
                }
            }
            
            // Create projectile
            function createProjectile(gem, targetEnemy) {
                // Calculate damage
                let damage = gem.damage;
                
                // Apply critical hit if applicable
                let isCritical = false;
                if (gem.specialEffect && gem.specialEffect.type === 'crit') {
                    if (Math.random() * 100 < gem.specialEffect.value) {
                        damage *= 2;
                        isCritical = true;
                    }
                }
                
                const projectile = {
                    x: gem.x + 0.5,  // Center of the gem cell
                    y: gem.y + 0.5,  // Center of the gem cell
                    targetEnemy: targetEnemy,
                    speed: 8,        // Grid units per second
                    damage: damage,
                    color: gem.color,
                    size: 6,
                    gem: gem,
                    isCritical: isCritical,
                    effects: []
                };
                
                // Add special effects to projectile
                if (gem.specialEffect) {
                    switch (gem.specialEffect.type) {
                        case 'slow':
                            projectile.effects.push({
                                type: 'slow',
                                value: gem.specialEffect.value,
                                duration: 3 // seconds
                            });
                            break;
                        case 'poison':
                            projectile.effects.push({
                                type: 'poison',
                                value: gem.specialEffect.value,
                                duration: 5 // seconds
                            });
                            break;
                        case 'splash':
                            projectile.splash = {
                                radius: 1.5,
                                damage: gem.damage * (gem.specialEffect.value / 100)
                            };
                            break;
                        case 'dot':
                            projectile.effects.push({
                                type: 'dot',
                                value: gem.specialEffect.value,
                                duration: 4 // seconds
                            });
                            break;
                    }
                }
                
                gameState.projectiles.push(projectile);
                
                // Play sound
                if (Math.random() < 0.2) { // Don't play for every projectile
                    playSound('enemyHit', 0.2);
                }
            }
            
            // Create chain projectile (from enemy to enemy)
            function createChainProjectile(fromEnemy, toEnemy, gem) {
                const projectile = {
                    x: fromEnemy.x,  // Start at previous enemy
                    y: fromEnemy.y,
                    targetEnemy: toEnemy,
                    speed: 12,        // Faster than normal projectiles
                    damage: gem.damage * 0.7, // Reduced damage for chains
                    color: gem.color,
                    size: 4,          // Smaller size
                    gem: gem,
                    isChain: true
                };
                
                gameState.projectiles.push(projectile);
            }
            
            // Update projectiles
            function updateProjectiles(deltaTime) {
                const secondsPassed = deltaTime / 1000;
                
                for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                    const projectile = gameState.projectiles[i];
                    const target = projectile.targetEnemy;
                    
                    // Check if target is still valid
                    if (!gameState.enemies.includes(target)) {
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Calculate direction to target
                    const dx = target.x - projectile.x;
                    const dy = target.y - projectile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Normalize direction
                    const ndx = dx / distance;
                    const ndy = dy / distance;
                    
                    // Move projectile (in grid units)
                    const cellsToMove = projectile.speed * secondsPassed;
                    projectile.x += ndx * cellsToMove;
                    projectile.y += ndy * cellsToMove;
                    
                    // Check if projectile hit enemy
                    if (distance < 0.2) {
                        // Apply damage
                        target.currentHealth -= projectile.damage;
                        
                        // Apply effects
                        if (projectile.effects && projectile.effects.length > 0) {
                            if (!target.effects) target.effects = [];
                            
                            // Add each effect
                            for (const effect of projectile.effects) {
                                // Check if effect already exists
                                const existingEffect = target.effects.find(e => e.type === effect.type);
                                
                                if (existingEffect) {
                                    // Refresh duration
                                    existingEffect.duration = Math.max(existingEffect.duration, effect.duration);
                                    // Take the stronger value
                                    existingEffect.value = Math.max(existingEffect.value, effect.value);
                                } else {
                                    // Add new effect
                                    target.effects.push({...effect});
                                }
                            }
                        }
                        
                        // Apply splash damage if applicable
                        if (projectile.splash) {
                            const splashRadius = projectile.splash.radius;
                            const splashDamage = projectile.splash.damage;
                            
                            // Find enemies in splash radius
                            for (const enemy of gameState.enemies) {
                                if (enemy !== target) {
                                    const splashDx = enemy.x - target.x;
                                    const splashDy = enemy.y - target.y;
                                    const splashDistance = Math.sqrt(splashDx * splashDx + splashDy * splashDy);
                                    
                                    if (splashDistance <= splashRadius) {
                                        // Apply splash damage (less damage the further away)
                                        const damageMultiplier = 1 - (splashDistance / splashRadius);
                                        enemy.currentHealth -= splashDamage * damageMultiplier;
                                        
                                        // Create visual effect
                                        addEffect({
                                            type: 'explosion',
                                            x: enemy.x,
                                            y: enemy.y,
                                            size: 0.3,
                                            color: projectile.color,
                                            duration: 0.3,
                                            currentTime: 0
                                        });
                                    }
                                }
                            }
                            
                            // Create splash visual effect
                            addEffect({
                                type: 'explosion',
                                x: target.x,
                                y: target.y,
                                size: projectile.splash.radius / 2,
                                color: projectile.color,
                                duration: 0.5,
                                currentTime: 0
                            });
                        } else if (projectile.isCritical) {
                            // Create critical hit effect
                            addEffect({
                                type: 'explosion',
                                x: target.x,
                                y: target.y,
                                size: 0.4,
                                color: '#ffffff',
                                duration: 0.3,
                                currentTime: 0
                            });
                            
                            // Add critical hit notification
                            addNotification({
                                text: 'CRIT!',
                                x: target.x * gameState.cellSize,
                                y: target.y * gameState.cellSize - 20,
                                color: '#ffff00',
                                size: 14,
                                duration: 1,
                                currentTime: 0,
                                position: null,
                                movement: -30  // Move upward
                            });
                        }
                        
                        // Remove projectile
                        gameState.projectiles.splice(i, 1);
                    }
                }
            }
            
            // Add effect
            function addEffect(effect) {
                gameState.effects.push(effect);
            }
            
            // Update effects
            function updateEffects(deltaTime) {
                const secondsPassed = deltaTime / 1000;
                
                for (let i = gameState.effects.length - 1; i >= 0; i--) {
                    const effect = gameState.effects[i];
                    
                    // Update effect time
                    effect.currentTime += secondsPassed;
                    
                    // Remove expired effects
                    if (effect.currentTime >= effect.duration) {
                        gameState.effects.splice(i, 1);
                    }
                }
            }
            
            // Add notification
            function addNotification(notification) {
                gameState.notifications.push(notification);
            }
            
            // Update notifications
            function updateNotifications(deltaTime) {
                const secondsPassed = deltaTime / 1000;
                
                for (let i = gameState.notifications.length - 1; i >= 0; i--) {
                    const notification = gameState.notifications[i];
                    
                    // Update notification time
                    notification.currentTime += secondsPassed;
                    
                    // Remove expired notifications
                    if (notification.currentTime >= notification.duration) {
                        gameState.notifications.splice(i, 1);
                    }
                }
                
                // Update wave announcement if active
                if (gameState.waveAnnouncement) {
                    gameState.waveAnnouncement.progress += secondsPassed / gameState.waveAnnouncement.duration;
                    
                    if (gameState.waveAnnouncement.progress >= 1) {
                        gameState.waveAnnouncement = null;
                    }
                }
            }
            
            // Update resources display
            function updateResourcesDisplay() {
                elements.livesDisplay.textContent = gameState.lives;
                elements.goldDisplay.textContent = gameState.gold;
                elements.levelDisplay.textContent = gameState.level;
                elements.scoreDisplay.textContent = gameState.score;
                elements.killCountDisplay.textContent = gameState.killCount;
                elements.mazeQualityDisplay.textContent = `${gameState.mazeQuality}%`;
                elements.specialChanceDisplay.textContent = `${gameState.specialChance}%`;
            }
            
            // Show message
            function showMessage(message, color) {
                // Create floating message element
                const messageEl = document.createElement('div');
                messageEl.textContent = message;
                messageEl.setAttribute('aria-live', 'assertive');
                messageEl.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: ${color};
                    font-size: 1.5em;
                    text-shadow: 0 0 10px ${color};
                    animation: fadeInOut 2s ease-in-out;
                    pointer-events: none;
                    z-index: 100;
                `;
                
                // Add to game container
                document.getElementById('game-container').appendChild(messageEl);
                
                // Remove after animation completes
                setTimeout(() => {
                    if (document.body.contains(messageEl)) {
                        messageEl.remove();
                    }
                }, 2000);
            }
            
            // Play sound
            function playSound(soundName, volume = 1.0) {
                if (ElifTD.Config.getAudioSettings().soundEnabled) {
                    ElifTD.Audio.playSound(soundName);
                }
            }
            
            // Game over
            function gameOver() {
                gameState.gameOver = true;
                
                // Play sound
                playSound('gameOver');
                
                // Create overlay with score and restart button
                const overlay = document.createElement('div');
                overlay.id = 'game-over-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(10, 10, 18, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 100;
                `;
                
                // Create content
                overlay.innerHTML = `
                    <div class="game-over-text">GAME OVER</div>
                    <div class="game-stats">FINAL SCORE: ${gameState.score}</div>
                    <div class="game-stats">WAVES COMPLETED: ${gameState.level - 1}</div>
                    <button id="restart-game-btn" class="game-button" style="padding: 10px 30px; font-size: 1.2em;">RESTART</button>
                `;
                
                // Add to game container
                document.getElementById('game-container').appendChild(overlay);
                
                // Add restart button event listener
                document.getElementById('restart-game-btn').addEventListener('click', restartGame);
            }
            
            // Restart game
            function restartGame() {
                // Remove game over overlay
                const overlay = document.getElementById('game-over-overlay');
                if (overlay) {
                    overlay.remove();
                }
                
                // Reset game state
                resetGameState();
                
                // Generate initial path
                calculatePath();
                
                // Fill gem inventory with starter gems
                populateStarterGems();
                
                // Update resource display
                updateResourcesDisplay();
                
                // Enable buttons
                elements.startWaveBtn.disabled = false;
                elements.nextWaveBtn.disabled = false;
                
                // Start background music
                ElifTD.Audio.startBackgroundMusic();
            }
            
            // Game loop
            function gameLoop(timestamp) {
                // Calculate delta time in milliseconds
                let deltaTime = timestamp - gameState.lastFrameTime;
                gameState.lastFrameTime = timestamp;
                
                // Limit delta time to avoid large jumps
                if (deltaTime > 100) deltaTime = 100;
                
                // Skip updates if game is paused
                if (!gameState.gamePaused && !gameState.gameOver) {
                    // Update game logic
                    updateGems(deltaTime);
                    updateProjectiles(deltaTime);
                    updateEffects(deltaTime);
                    updateNotifications(deltaTime);
                    
                    if (gameState.waveInProgress) {
                        updateEnemies(deltaTime);
                        gameState.waveElapsed += deltaTime;
                    }
                }
                
                // Clear canvas
                ElifTD.Renderer.clearCanvas();
                
                // Draw cyberpunk background effect
                ElifTD.Renderer.drawCyberpunkEffects(gameState.canvas.width, gameState.canvas.height);
                
                // Draw game elements
                ElifTD.Renderer.drawGrid(gameState.grid, gameState.cellSize, gameState.hoverCell, gameState.buildMode);
                ElifTD.Renderer.drawPath(gameState.path, gameState.cellSize);
                ElifTD.Renderer.drawGems(gameState.gems, gameState.cellSize, gameState.hoverCell);
                ElifTD.Renderer.drawEnemies(gameState.enemies, gameState.cellSize);
                ElifTD.Renderer.drawProjectiles(gameState.projectiles, gameState.cellSize);
                ElifTD.Renderer.drawEffects(gameState.effects, gameState.cellSize);
                ElifTD.Renderer.drawNotifications(gameState.notifications, gameState.canvas.width, gameState.canvas.height);
                
                // Draw wave announcement if active
                if (gameState.waveAnnouncement) {
                    ElifTD.Renderer.drawWaveAnnouncement(
                        gameState.waveAnnouncement.text, 
                        gameState.waveAnnouncement.progress, 
                        gameState.canvas.width, 
                        gameState.canvas.height
                    );
                }
                
                // Continue the game loop
                requestAnimationFrame(gameLoop);
            }
            
            // Public interface
            return {
                init,
                startGame,
                restartGame,
                pauseGame,
                resumeGame,
                showHelpModal
            };
        })();
        
        /*** LOADING MODULE ***/
        ElifTD.Loading = (function() {
            let progress = 0;
            let loadingScreen;
            let loadingBar;
            let loadingText;
            
            // Initialize loading screen
            function init() {
                loadingScreen = document.getElementById('loading-screen');
                loadingBar = document.getElementById('loading-bar');
                loadingText = document.getElementById('loading-text');
                
                updateProgress(0, 'Initializing systems...');
            }
            
            // Update loading progress
            function updateProgress(percent, message) {
                progress = percent;
                loadingBar.style.width = `${percent}%`;
                
                if (message) {
                    loadingText.textContent = message;
                }
            }
            
            // Show loading screen
            function show() {
                loadingScreen.style.display = 'flex';
            }
            
            // Hide loading screen
            function hide() {
                // Ensure we're at 100% before hiding
                updateProgress(100, 'Ready!');
                
                // Fade out
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transition = 'opacity 0.5s';
                    
                    // Remove from DOM after fade
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 500);
            }
            
            // Simulate loading process
            function startLoading() {
                show();
                
                // Simulate a loading sequence
                setTimeout(() => updateProgress(15, 'Loading game assets...'), 300);
                setTimeout(() => updateProgress(35, 'Initializing game engine...'), 700);
                setTimeout(() => updateProgress(50, 'Loading audio...'), 1100);
                setTimeout(() => updateProgress(70, 'Configuring game systems...'), 1500);
                setTimeout(() => updateProgress(85, 'Generating world...'), 1900);
                setTimeout(() => updateProgress(95, 'Finalizing setup...'), 2300);
                
                // When complete, initialize the game
                setTimeout(() => {
                    updateProgress(100, 'Ready!');
                    
                    // Initialize game
                    ElifTD.Game.init();
                    
                    // Hide loading screen
                    hide();
                }, 2700);
            }
            
            // Public interface
            return {
                init,
                startLoading,
                updateProgress,
                show,
                hide
            };
        })();
        
        /*** BOOTSTRAP THE GAME ***/
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize loading screen
            ElifTD.Loading.init();
            
            // Start loading process
            ElifTD.Loading.startLoading();
        });
    </script>
</body>
</html>
