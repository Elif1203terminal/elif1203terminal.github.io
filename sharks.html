<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Evolutionary Aquarium Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000033; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            min-width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #pauseControl {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        button { padding: 5px 10px; margin: 2px; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
    <button id="resetBtn">Reset Simulation</button>
</div>
<div id="info"></div>
<div id="pauseControl">
    <button id="pauseBtn">Pause</button>
</div>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    // Simulation variables
    const FOOD_PER_GENERATION = 150; // Increased food
    const MAX_GENERATION_TIME = 3000; // Maximum frames per generation (lifespan)
    const MAX_FISH_EGGS = 10; // Maximum eggs needed to trigger new generation
    const FISH_PER_GENERATION = 10; // 5 males, 5 females

    let fishes = [];
    let sharks = [];
    let fishEggs = [];
    let sharkEggs = [];
    let foodPellets = [];
    let fishGeneration = 0;
    let sharkGeneration = 0;
    let generationTimer = 0;
    let totalFishEggsThisGeneration = 0;
    let totalSharkEggsThisGeneration = 0;
    let totalFoodThisGeneration = 0;
    let isPaused = false;
    class Fish {
        constructor(parents = null) {
            // Physical traits - wider ranges for more visible evolution
            this.bodyWidth = 0.6 + Math.random() * 0.8;
            this.bodyHeight = 0.6 + Math.random() * 0.8;
            this.eyeSize = 0.05 + Math.random() * 0.3;
            this.finSize = 0.2 + Math.random() * 0.6;
            this.symmetry = 0.5 + Math.random() * 0.7;
            
            // More diverse color traits with patterns
            this.bodyColor = [Math.random(), Math.random(), Math.random()];
            this.eyeColor = [Math.random(), Math.random(), Math.random()];
            this.finColor = [Math.random(), Math.random(), Math.random()];
            this.hasStripes = Math.random() < 0.3;
            this.stripeColor = [Math.random(), Math.random(), Math.random()];
            this.stripeDensity = 0.2 + Math.random() * 0.8;
            this.hasSpots = Math.random() < 0.3;
            this.spotColor = [Math.random(), Math.random(), Math.random()];
            this.spotDensity = 0.2 + Math.random() * 0.8;
            
            // Position & movement
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = 1 + Math.random() * 0.5;
            
            // Enhanced beauty preferences
            this.beautyWeights = {
                symmetry: 0.8 + Math.random() * 0.4,
                eyeSize: 0.8 + Math.random() * 0.4,
                finSize: 0.8 + Math.random() * 0.4,
                bodyShape: 0.8 + Math.random() * 0.4,
                colorPreference: [Math.random(), Math.random(), Math.random()], // Preferred colors
                patternPreference: Math.random(), // 0 = plain, 0.5 = stripes, 1 = spots
                colorVibrancy: 0.8 + Math.random() * 0.4
            };
            
            // Breeding state
            this.isFemale = Math.random() < 0.5;
            this.hasMated = false;
            this.eggsLaid = 0;
            this.cooldown = 0;
            this.searchingTime = 0;
            this.preferredMate = null;
            this.attractionThreshold = 1.5; // Lower initial threshold
            this.courtingPartner = null;
            this.courtingTime = 0;
            this.dancePhase = 0;
            
            // Food and energy system
            this.foodPoints = 0;
            this.hunger = 0;
            this.targetFood = null;
            this.canMate = false;
            this.age = 0;
            
            // Food finding abilities (evolvable traits)
            this.visionRange = 30 + Math.random() * 70; // Visual detection range
            this.visionAngle = Math.PI / 4 + Math.random() * Math.PI / 2; // Field of view
            this.smellSensitivity = 0.01 + Math.random() * 0.09; // How well they detect faint scents
            this.foodSpeed = 0.8 + Math.random() * 0.4; // Speed boost when hunting
            
            // Predator avoidance traits
            this.odorStrength = 0.5 + Math.random() * 0.5; // How much smell fish emits (lower is better)
            this.fleeSpeed = 1.2 + Math.random() * 0.8; // Speed boost when fleeing
            this.predatorDetectionRange = 100 + Math.random() * 100; // How far they can see sharks
            
            // Hunting strategy (0-1, where 0 = vision-based, 1 = smell-based)
            this.huntingStrategy = Math.random();
            
            if (parents) this.inheritTraits(parents);
        }

        inheritTraits(parents) {
            // Mutation rate approximately 6% per trait
            const mutationRate = 0.06;
            
            // Inherit physical traits with mutation
            this.bodyWidth = this.inheritTrait(parents[0].bodyWidth, parents[1].bodyWidth, mutationRate);
            this.bodyHeight = this.inheritTrait(parents[0].bodyHeight, parents[1].bodyHeight, mutationRate);
            this.eyeSize = this.inheritTrait(parents[0].eyeSize, parents[1].eyeSize, mutationRate);
            this.finSize = this.inheritTrait(parents[0].finSize, parents[1].finSize, mutationRate);
            this.symmetry = this.inheritTrait(parents[0].symmetry, parents[1].symmetry, mutationRate);
            
            // Inherit color traits with mutation
            for (let i = 0; i < 3; i++) {
                this.bodyColor[i] = this.inheritTrait(parents[0].bodyColor[i], parents[1].bodyColor[i], mutationRate);
                this.eyeColor[i] = this.inheritTrait(parents[0].eyeColor[i], parents[1].eyeColor[i], mutationRate);
                this.finColor[i] = this.inheritTrait(parents[0].finColor[i], parents[1].finColor[i], mutationRate);
                this.stripeColor[i] = this.inheritTrait(parents[0].stripeColor[i], parents[1].stripeColor[i], mutationRate);
                this.spotColor[i] = this.inheritTrait(parents[0].spotColor[i], parents[1].spotColor[i], mutationRate);
            }
            
            // Inherit pattern traits
            if (Math.random() < 0.5) {
                this.hasStripes = parents[0].hasStripes;
                this.stripeDensity = this.inheritTrait(parents[0].stripeDensity, parents[1].stripeDensity, mutationRate);
            } else {
                this.hasStripes = parents[1].hasStripes;
                this.stripeDensity = this.inheritTrait(parents[1].stripeDensity, parents[0].stripeDensity, mutationRate);
            }
            
            if (Math.random() < 0.5) {
                this.hasSpots = parents[0].hasSpots;
                this.spotDensity = this.inheritTrait(parents[0].spotDensity, parents[1].spotDensity, mutationRate);
            } else {
                this.hasSpots = parents[1].hasSpots;
                this.spotDensity = this.inheritTrait(parents[1].spotDensity, parents[0].spotDensity, mutationRate);
            }
            
            // Chance for pattern mutation
            if (Math.random() < mutationRate * 2) {
                this.hasStripes = !this.hasStripes;
            }
            if (Math.random() < mutationRate * 2) {
                this.hasSpots = !this.hasSpots;
            }
            
            // Inherit beauty preferences with mutation
            for (const key in this.beautyWeights) {
                if (key === 'colorPreference') {
                    for (let i = 0; i < 3; i++) {
                        this.beautyWeights.colorPreference[i] = this.inheritTrait(
                            parents[0].beautyWeights.colorPreference[i],
                            parents[1].beautyWeights.colorPreference[i],
                            mutationRate * 2
                        );
                    }
                } else if (key === 'patternPreference') {
                    this.beautyWeights.patternPreference = this.inheritTrait(
                        parents[0].beautyWeights.patternPreference,
                        parents[1].beautyWeights.patternPreference,
                        mutationRate * 2
                    );
                } else {
                    this.beautyWeights[key] = this.inheritTrait(
                        parents[0].beautyWeights[key], 
                        parents[1].beautyWeights[key], 
                        mutationRate * 2  // Beauty preferences evolve faster
                    );
                }
            }
            
            // Inherit food-finding abilities
            this.visionRange = this.inheritTrait(parents[0].visionRange, parents[1].visionRange, mutationRate);
            this.visionAngle = this.inheritTrait(parents[0].visionAngle, parents[1].visionAngle, mutationRate);
            this.smellSensitivity = this.inheritTrait(parents[0].smellSensitivity, parents[1].smellSensitivity, mutationRate);
            this.foodSpeed = this.inheritTrait(parents[0].foodSpeed, parents[1].foodSpeed, mutationRate);
            this.huntingStrategy = this.inheritTrait(parents[0].huntingStrategy, parents[1].huntingStrategy, mutationRate);
            
            // Inherit predator avoidance traits
            this.odorStrength = this.inheritTrait(parents[0].odorStrength, parents[1].odorStrength, mutationRate);
            this.fleeSpeed = this.inheritTrait(parents[0].fleeSpeed, parents[1].fleeSpeed, mutationRate);
            this.predatorDetectionRange = this.inheritTrait(parents[0].predatorDetectionRange, parents[1].predatorDetectionRange, mutationRate);
        }
        inheritTrait(parent1Trait, parent2Trait, mutationRate) {
            let inherited;
            
            // 50% chance to inherit from either parent, or blend them
            const inheritType = Math.random();
            if (inheritType < 0.4) {
                inherited = parent1Trait;
            } else if (inheritType < 0.8) {
                inherited = parent2Trait;
            } else {
                inherited = (parent1Trait + parent2Trait) / 2;
            }
            
            // Apply mutation
            if (Math.random() < mutationRate) {
                inherited += (Math.random() - 0.5) * 0.3; // Increased mutation amount
            }
            
            // Keep values reasonable but allow more range for physical traits
            return Math.max(0.01, Math.min(3.0, inherited));
        }

        evaluateBeauty(other) {
            let score = 0;
            
            // Basic physical traits
            score += this.beautyWeights.symmetry * other.symmetry;
            score += this.beautyWeights.eyeSize * other.eyeSize;
            score += this.beautyWeights.finSize * other.finSize;
            
            // Body shape preference (ideal ratio)
            const bodyRatio = other.bodyWidth / other.bodyHeight;
            const idealRatio = 1.5; 
            score += this.beautyWeights.bodyShape * (1 - Math.abs(idealRatio - bodyRatio));
            
            // Color preference - how close other's colors are to preferred colors
            const bodyColorMatch = this.calculateColorMatch(other.bodyColor, this.beautyWeights.colorPreference);
            score += bodyColorMatch * 2; // Color is an important factor
            
            // Pattern preference
            let patternScore = 0;
            if (other.hasStripes && this.beautyWeights.patternPreference > 0.3 && this.beautyWeights.patternPreference < 0.7) {
                patternScore = 1 - Math.abs(0.5 - this.beautyWeights.patternPreference);
            } else if (other.hasSpots && this.beautyWeights.patternPreference > 0.7) {
                patternScore = this.beautyWeights.patternPreference - 0.7;
            } else if (!other.hasStripes && !other.hasSpots && this.beautyWeights.patternPreference < 0.3) {
                patternScore = 0.3 - this.beautyWeights.patternPreference;
            }
            score += patternScore * 1.5;
            
            // Color vibrancy (how saturated the colors are)
            const colorVibrancy = this.calculateColorVibrancy(other.bodyColor);
            score += this.beautyWeights.colorVibrancy * colorVibrancy;
            
            // Well-fed fish are slightly more attractive
            if (other.foodPoints > 10) {
                score *= 1 + (other.foodPoints - 10) * 0.01; // Max 30% boost at 40 food points
            }
            
            // Scale up the score to make differences more significant
            return score * 2;
        }

        calculateColorVibrancy(color) {
            const max = Math.max(...color);
            const min = Math.min(...color);
            return (max - min);
        }
        
        calculateColorMatch(color1, color2) {
            // Calculate how close two colors are (0-1, where 1 is perfect match)
            let match = 0;
            for (let i = 0; i < 3; i++) {
                match += 1 - Math.abs(color1[i] - color2[i]);
            }
            return match / 3;
        }
        
        detectPredator() {
            let closestShark = null;
            let closestDist = Infinity;
            
            for (const shark of sharks) {
                // Only detect hunting sharks
                if (!shark.isHunting()) continue;
                
                const dx = shark.x - this.x;
                const dy = shark.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < this.predatorDetectionRange && dist < closestDist) {
                    closestDist = dist;
                    closestShark = shark;
                }
            }
            
            return closestShark;
        }
        update() {
            if (this.cooldown > 0) this.cooldown--;
            this.age++;
            
            // First, check for predators
            const predator = this.detectPredator();
            
            if (predator && !this.courtingPartner) {
                // Flee from predator (if not courting)
                const dx = this.x - predator.x;
                const dy = this.y - predator.y;
                this.angle = Math.atan2(dy, dx);
                
                // Move faster when fleeing
                this.x += Math.cos(this.angle) * this.speed * this.fleeSpeed;
                this.y += Math.sin(this.angle) * this.speed * this.fleeSpeed;
            } else {
                // No predator detected or currently courting
                
                // Find food if not yet able to mate
                if (!this.canMate && !this.targetFood) {
                    let bestFood = null;
                    let bestScore = -Infinity;
                    
                    for (const food of foodPellets) {
                        const dx = food.x - this.x;
                        const dy = food.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if can detect food
                        let canDetect = false;
                        let detectionScore = 0;
                        
                        // Visual detection (directional)
                        const angleToFood = Math.atan2(dy, dx);
                        const angleDiff = Math.abs(angleToFood - this.angle);
                        const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        if (dist < this.visionRange && normalizedAngleDiff < this.visionAngle / 2) {
                            canDetect = true;
                            detectionScore = (1 - dist / this.visionRange) * (1 - this.huntingStrategy);
                        }
                        
                        // Smell detection (based on scent strength)
                        const scentStrength = food.getScentStrengthAt(this.x, this.y);
                        if (scentStrength > this.smellSensitivity) {
                            canDetect = true;
                            const smellScore = scentStrength * this.huntingStrategy;
                            detectionScore = Math.max(detectionScore, smellScore);
                        }
                        
                        // Choose the best detected food
                        if (canDetect && detectionScore > bestScore) {
                            bestScore = detectionScore;
                            bestFood = food;
                        }
                    }
                    
                    this.targetFood = bestFood;
                }
                
                // Move towards food if hunting, otherwise normal swimming
                if (this.targetFood && !this.canMate) {
                    const dx = this.targetFood.x - this.x;
                    const dy = this.targetFood.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Check if reached food
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 10) {
                        this.foodPoints += this.targetFood.value;
                        const index = foodPellets.indexOf(this.targetFood);
                        if (index > -1) {
                            foodPellets.splice(index, 1);
                        }
                        this.targetFood = null;
                        
                        // Check if can mate now
                        if (this.foodPoints >= 10) {
                            this.canMate = true;
                        }
                    }
                    
                    // Move faster when hunting food
                    this.x += Math.cos(this.angle) * this.speed * this.foodSpeed;
                    this.y += Math.sin(this.angle) * this.speed * this.foodSpeed;
                } else if (!this.courtingPartner) {
                    // Normal swimming behavior when not courting
                    this.wanderAngle = this.wanderAngle || 0;
                    this.wanderAngle += (Math.random() - 0.5) * 0.3;
                    this.angle += Math.sin(this.wanderAngle) * 0.03;
                    
                    // Normal speed
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                }
            }
            
            // Vary base speed occasionally
            if (Math.random() < 0.01) {
                this.speed = 0.8 + Math.random() * 1.2;
            }
            
            // Hard boundaries - bounce off walls
            const margin = 20;
            if (this.x < margin) {
                this.x = margin;
                this.angle = Math.PI - this.angle;
            } else if (this.x > width - margin) {
                this.x = width - margin;
                this.angle = Math.PI - this.angle;
            }
            if (this.y < margin) {
                this.y = margin;
                this.angle = -this.angle;
            } else if (this.y > height - margin) {
                this.y = height - margin;
                this.angle = -this.angle;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // Draw vision cone if hunting
            if (!this.canMate && this.targetFood) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, this.visionRange, -this.visionAngle/2, this.visionAngle/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw scent detection indicator (pulsing nose)
                if (this.targetFood && this.targetFood.getScentStrengthAt(this.x, this.y) > this.smellSensitivity) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    const pulseSize = 5 + Math.sin(Date.now() * 0.005) * 2;
                    ctx.beginPath();
                    ctx.arc(this.bodyWidth * 12, 0, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw body
            ctx.fillStyle = `rgb(${Math.floor(this.bodyColor[0]*255)},${Math.floor(this.bodyColor[1]*255)},${Math.floor(this.bodyColor[2]*255)})`;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.bodyWidth * 15, this.bodyHeight * 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw patterns
            if (this.hasStripes) {
                ctx.fillStyle = `rgb(${Math.floor(this.stripeColor[0]*255)},${Math.floor(this.stripeColor[1]*255)},${Math.floor(this.stripeColor[2]*255)})`;
                const stripeCount = Math.floor(3 + this.stripeDensity * 6);
                const stripeWidth = (this.bodyWidth * 30) / stripeCount;
                
                for (let i = 0; i < stripeCount; i++) {
                    const stripeX = -this.bodyWidth * 15 + i * stripeWidth;
                    ctx.fillRect(stripeX, -this.bodyHeight * 10, stripeWidth * 0.6, this.bodyHeight * 20);
                }
            }
            
            if (this.hasSpots) {
                ctx.fillStyle = `rgb(${Math.floor(this.spotColor[0]*255)},${Math.floor(this.spotColor[1]*255)},${Math.floor(this.spotColor[2]*255)})`;
                const spotCount = Math.floor(3 + this.spotDensity * 8);
                
                for (let i = 0; i < spotCount; i++) {
                    const spotX = (Math.random() - 0.5) * this.bodyWidth * 20;
                    const spotY = (Math.random() - 0.5) * this.bodyHeight * 12;
                    const spotSize = 1 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw tail fin
            ctx.fillStyle = `rgb(${Math.floor(this.finColor[0]*255)},${Math.floor(this.finColor[1]*255)},${Math.floor(this.finColor[2]*255)})`;
            ctx.beginPath();
            ctx.moveTo(-this.bodyWidth * 15, 0);
            ctx.lineTo(-this.bodyWidth * 15 - this.finSize * 20, -this.finSize * 10);
            ctx.lineTo(-this.bodyWidth * 15 - this.finSize * 20, this.finSize * 10);
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes (symmetry affects eye placement)
            const eyeOffset = this.bodyHeight * 3 * this.symmetry;
            ctx.fillStyle = `rgb(${Math.floor(this.eyeColor[0]*255)},${Math.floor(this.eyeColor[1]*255)},${Math.floor(this.eyeColor[2]*255)})`;
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 5, -eyeOffset, this.eyeSize * 5, 0, Math.PI * 2);
            ctx.arc(this.bodyWidth * 5, eyeOffset, this.eyeSize * 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 5, -eyeOffset, this.eyeSize * 2, 0, Math.PI * 2);
            ctx.arc(this.bodyWidth * 5, eyeOffset, this.eyeSize * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Get the scent strength at a particular location
        getScentStrengthAt(x, y) {
            const dx = x - this.x;
            const dy = y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const decayRate = 0.01;
            
            // Scale by odorStrength (lower is better at hiding)
            return this.odorStrength * Math.exp(-distance * decayRate);
        }
    }
    class Shark {
        constructor(parents = null) {
            // Physical traits
            this.bodyWidth = 1.2 + Math.random() * 0.6;
            this.bodyHeight = 0.8 + Math.random() * 0.4;
            this.finSize = 0.6 + Math.random() * 0.4;
            
            // Color traits with patterns
            this.bodyColor = [0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3]; // Gray
            this.finColor = [0.2 + Math.random() * 0.2, 0.2 + Math.random() * 0.2, 0.4 + Math.random() * 0.4]; // Dark blue-gray
            this.hasPatches = Math.random() < 0.5;
            this.patchColor = [0.1 + Math.random() * 0.2, 0.1 + Math.random() * 0.2, 0.1 + Math.random() * 0.2]; // Dark patches
            
            // Position & movement
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = 0.8 + Math.random() * 0.4;
            
            // Hunting traits (evolvable)
            this.visionRange = 150 + Math.random() * 100;
            this.visionAngle = Math.PI / 3 + Math.random() * Math.PI / 3;
            this.smellSensitivity = 0.01 + Math.random() * 0.05;
            this.huntSpeed = 1.3 + Math.random() * 0.7;
            this.huntingCooldown = 0;  // Time until shark hunts again after eating
            this.maxHuntingCooldown = 300 + Math.random() * 300; // Around 5-10 seconds of rest
            
            // Breeding state
            this.isFemale = Math.random() < 0.5;
            this.fishEaten = 0;
            this.eggsLaid = 0;
            this.canMate = false;
            this.cooldown = 0;
            this.courtingPartner = null;
            this.courtingTime = 0;
            this.age = 0;
            
            // Hunting state
            this.targetFish = null;
            
            if (parents) this.inheritTraits(parents);
        }
        
        inheritTraits(parents) {
            // Mutation rate approximately 6% per trait
            const mutationRate = 0.06;
            
            // Inherit physical traits with mutation
            this.bodyWidth = this.inheritTrait(parents[0].bodyWidth, parents[1].bodyWidth, mutationRate);
            this.bodyHeight = this.inheritTrait(parents[0].bodyHeight, parents[1].bodyHeight, mutationRate);
            this.finSize = this.inheritTrait(parents[0].finSize, parents[1].finSize, mutationRate);
            
            // Inherit color traits with mutation
            for (let i = 0; i < 3; i++) {
                this.bodyColor[i] = this.inheritTrait(parents[0].bodyColor[i], parents[1].bodyColor[i], mutationRate);
                this.finColor[i] = this.inheritTrait(parents[0].finColor[i], parents[1].finColor[i], mutationRate);
                this.patchColor[i] = this.inheritTrait(parents[0].patchColor[i], parents[1].patchColor[i], mutationRate);
            }
            
            // Inherit pattern traits
            if (Math.random() < 0.5) {
                this.hasPatches = parents[0].hasPatches;
            } else {
                this.hasPatches = parents[1].hasPatches;
            }
            
            // Chance for pattern mutation
            if (Math.random() < mutationRate * 2) {
                this.hasPatches = !this.hasPatches;
            }
            
            // Inherit hunting traits
            this.visionRange = this.inheritTrait(parents[0].visionRange, parents[1].visionRange, mutationRate);
            this.visionAngle = this.inheritTrait(parents[0].visionAngle, parents[1].visionAngle, mutationRate);
            this.smellSensitivity = this.inheritTrait(parents[0].smellSensitivity, parents[1].smellSensitivity, mutationRate);
            this.huntSpeed = this.inheritTrait(parents[0].huntSpeed, parents[1].huntSpeed, mutationRate);
            this.maxHuntingCooldown = this.inheritTrait(parents[0].maxHuntingCooldown, parents[1].maxHuntingCooldown, mutationRate);
        }
        
        inheritTrait(parent1Trait, parent2Trait, mutationRate) {
            let inherited;
            
            // 50% chance to inherit from either parent, or blend them
            const inheritType = Math.random();
            if (inheritType < 0.4) {
                inherited = parent1Trait;
            } else if (inheritType < 0.8) {
                inherited = parent2Trait;
            } else {
                inherited = (parent1Trait + parent2Trait) / 2;
            }
            
            // Apply mutation
            if (Math.random() < mutationRate) {
                inherited += (Math.random() - 0.5) * 0.3; // Increased mutation amount
            }
            
            // Keep values reasonable but allow more range for physical traits
            return Math.max(0.01, Math.min(3.0, inherited));
        }
        
        isHunting() {
            // Check if shark is currently in hunting mode
            return this.fishEaten < 2 && this.huntingCooldown <= 0 && !this.courtingPartner;
        }
        
        findPrey() {
            // Only hunt if not satiated and not in cooldown
            if (!this.isHunting()) return null;
            
            // Don't hunt breeding fish
            const huntableFish = fishes.filter(fish => !fish.courtingPartner);
            if (huntableFish.length === 0) return null;
            
            let bestPrey = null;
            let bestScore = -Infinity;
            
            for (const fish of huntableFish) {
                const dx = fish.x - this.x;
                const dy = fish.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if can detect fish
                let canDetect = false;
                let detectionScore = 0;
                
                // Visual detection (directional)
                const angleToFish = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angleToFish - this.angle);
                const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                
                if (dist < this.visionRange && normalizedAngleDiff < this.visionAngle / 2) {
                    canDetect = true;
                    detectionScore = (1 - dist / this.visionRange);
                }
                
                // Smell detection (based on fish's odor strength)
                const scentStrength = fish.getScentStrengthAt(this.x, this.y);
                if (scentStrength > this.smellSensitivity) {
                    canDetect = true;
                    detectionScore = Math.max(detectionScore, scentStrength);
                }
                
                // Choose the best detected prey
                if (canDetect && detectionScore > bestScore) {
                    bestScore = detectionScore;
                    bestPrey = fish;
                }
            }
            
            return bestPrey;
        }
        update() {
            if (this.cooldown > 0) this.cooldown--;
            if (this.huntingCooldown > 0) this.huntingCooldown--;
            this.age++;
            
            if (this.courtingPartner) {
                // Handle courtship
                this.performCourtship();
            } else {
                // Normal hunting behavior
                if (this.isHunting() && !this.targetFish) {
                    this.targetFish = this.findPrey();
                }
                
                if (this.targetFish) {
                    // Hunt target fish
                    const dx = this.targetFish.x - this.x;
                    const dy = this.targetFish.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Check if reached fish
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 20) {
                        // Eat the fish
                        const index = fishes.indexOf(this.targetFish);
                        if (index > -1) {
                            fishes.splice(index, 1);
                        }
                        
                        this.fishEaten++;
                        this.targetFish = null;
                        
                        // Check if can mate now
                        if (this.fishEaten >= 1) {
                            this.canMate = true;
                        }
                        
                        // Start resting period after eating 2 fish
                        if (this.fishEaten >= 2) {
                            this.huntingCooldown = this.maxHuntingCooldown;
                        }
                    }
                    
                    // Move faster when hunting
                    this.x += Math.cos(this.angle) * this.speed * this.huntSpeed;
                    this.y += Math.sin(this.angle) * this.speed * this.huntSpeed;
                } else {
                    // Normal swimming behavior
                    this.wanderAngle = this.wanderAngle || 0;
                    this.wanderAngle += (Math.random() - 0.5) * 0.2;
                    this.angle += Math.sin(this.wanderAngle) * 0.02;
                    
                    // Normal speed
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                }
                
                // Look for mate if can mate
                if (this.canMate && totalSharkEggsThisGeneration < 3 && this.cooldown === 0) {
                    const mate = this.findMate();
                    
                    if (mate && !mate.courtingPartner) {
                        // Start courtship
                        this.courtingPartner = mate;
                        mate.courtingPartner = this;
                        this.courtingTime = 0;
                        mate.courtingTime = 0;
                    }
                }
            }
            
            // Hard boundaries - bounce off walls
            const margin = 20;
            if (this.x < margin) {
                this.x = margin;
                this.angle = Math.PI - this.angle;
            } else if (this.x > width - margin) {
                this.x = width - margin;
                this.angle = Math.PI - this.angle;
            }
            if (this.y < margin) {
                this.y = margin;
                this.angle = -this.angle;
            } else if (this.y > height - margin) {
                this.y = height - margin;
                this.angle = -this.angle;
            }
        }
        findMate() {
            for (const shark of sharks) {
                if (shark !== this && 
                    shark.canMate && 
                    !shark.courtingPartner && 
                    shark.isFemale !== this.isFemale) {
                    return shark;
                }
            }
            return null;
        }
        
        performCourtship() {
            const partner = this.courtingPartner;
            this.courtingTime++;
            
            // Calculate center point between the two fish
            const centerX = (this.x + partner.x) / 2;
            const centerY = (this.y + partner.y) / 2;
            
            // Circling pattern
            const radius = 30;
            const speed = 0.03;
            const offset = this.isFemale ? 0 : Math.PI;
            
            this.x = centerX + Math.cos(this.courtingTime * speed + offset) * radius;
            this.y = centerY + Math.sin(this.courtingTime * speed + offset) * radius;
            
            // Face each other
            this.angle = Math.atan2(partner.y - this.y, partner.x - this.x);
            
            // After 10 seconds (600 frames at 60fps), mate
            if (this.courtingTime > 600) {
                if (this.isFemale && totalSharkEggsThisGeneration < 3) {
                    // Female lays egg
                    sharkEggs.push({
                        x: this.x,
                        y: this.y,
                        hatchTime: 0,
                        maxHatchTime: 300, // Longer hatch time for sharks
                        parents: [this, partner]
                    });
                    
                    this.eggsLaid++;
                    totalSharkEggsThisGeneration++;
                }
                
                // End courtship
                this.cooldown = 180;
                partner.cooldown = 180;
                this.courtingPartner = null;
                partner.courtingPartner = null;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // Draw vision cone if hunting
            if (this.isHunting() && this.targetFish) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, this.visionRange, -this.visionAngle/2, this.visionAngle/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw smell detection radius
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 100, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw body
            ctx.fillStyle = `rgb(${Math.floor(this.bodyColor[0]*255)},${Math.floor(this.bodyColor[1]*255)},${Math.floor(this.bodyColor[2]*255)})`;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.bodyWidth * 25, this.bodyHeight * 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw patches if present
            if (this.hasPatches) {
                ctx.fillStyle = `rgb(${Math.floor(this.patchColor[0]*255)},${Math.floor(this.patchColor[1]*255)},${Math.floor(this.patchColor[2]*255)})`;
                
                // Draw random shaped patches
                for (let i = 0; i < 6; i++) {
                    const patchX = (Math.random() - 0.5) * this.bodyWidth * 40;
                    const patchY = (Math.random() - 0.5) * this.bodyHeight * 22;
                    const patchSize = 3 + Math.random() * 6;
                    
                    ctx.beginPath();
                    ctx.ellipse(patchX, patchY, patchSize, patchSize * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw dorsal fin
            ctx.fillStyle = `rgb(${Math.floor(this.finColor[0]*255)},${Math.floor(this.finColor[1]*255)},${Math.floor(this.finColor[2]*255)})`;
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.lineTo(0, -this.finSize * 30);
            ctx.lineTo(5, 0);
            ctx.closePath();
            ctx.fill();
            
            // Draw tail fin
            ctx.fillStyle = `rgb(${Math.floor(this.finColor[0]*255)},${Math.floor(this.finColor[1]*255)},${Math.floor(this.finColor[2]*255)})`;
            ctx.beginPath();
            ctx.moveTo(-this.bodyWidth * 20, 0);
            ctx.lineTo(-this.bodyWidth * 20 - this.finSize * 30, -this.finSize * 15);
            ctx.lineTo(-this.bodyWidth * 20 - this.finSize * 30, this.finSize * 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 15, -this.bodyHeight * 5, 5, 0, Math.PI * 2);
            ctx.arc(this.bodyWidth * 15, this.bodyHeight * 5, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw hunting status indicator
            if (!this.isHunting() && this.fishEaten >= 2) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(this.bodyWidth * 15 + 10, 0, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
    }
    class FoodPellet {
        constructor() {
            this.x = Math.random() * (width - 40) + 20;
            this.y = Math.random() * (height - 40) + 20;
            this.value = 5; // Each pellet is worth 5 points
            this.radius = 3;
            this.scentStrength = 1.0; // How strong the scent is at the source
            this.scentDecayRate = 0.02; // How quickly scent fades with distance
        }

        draw(ctx) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        getScentStrengthAt(x, y) {
            const dx = x - this.x;
            const dy = y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // Scent strength decreases exponentially with distance
            return this.scentStrength * Math.exp(-distance * this.scentDecayRate);
        }
    }
    function createInitialGeneration() {
        fishes = [];
        sharks = [];
        fishEggs = [];
        sharkEggs = [];
        foodPellets = [];
        generationTimer = 0;
        totalFishEggsThisGeneration = 0;
        totalSharkEggsThisGeneration = 0;
        totalFoodThisGeneration = 0;
        fishGeneration = 0;
        sharkGeneration = 0;
        
        // Create 10 initial fish (5 males, 5 females)
        const fishColors = [
            // Males - more vibrant colors
            { body: [0.2, 0.6, 1.0], eye: [1.0, 1.0, 0.0], fin: [0.1, 0.3, 0.8] },  // Blue
            { body: [0.8, 0.2, 0.2], eye: [1.0, 1.0, 0.0], fin: [0.9, 0.1, 0.1] },  // Red
            { body: [0.2, 0.8, 0.2], eye: [1.0, 1.0, 0.0], fin: [0.1, 0.6, 0.1] },  // Green
            { body: [0.8, 0.8, 0.2], eye: [0.0, 0.0, 0.0], fin: [0.6, 0.6, 0.1] },  // Yellow
            { body: [0.6, 0.3, 0.8], eye: [1.0, 1.0, 0.0], fin: [0.4, 0.2, 0.6] },  // Purple
            // Females - more subtle colors
            { body: [1.0, 0.6, 0.2], eye: [0.8, 0.8, 0.2], fin: [0.8, 0.4, 0.1] },  // Orange
            { body: [0.2, 0.7, 0.7], eye: [1.0, 1.0, 0.0], fin: [0.1, 0.5, 0.5] },  // Teal
            { body: [0.8, 0.3, 0.5], eye: [1.0, 1.0, 1.0], fin: [0.6, 0.2, 0.4] },  // Pink
            { body: [0.5, 0.5, 0.5], eye: [1.0, 1.0, 0.0], fin: [0.3, 0.3, 0.3] },  // Gray
            { body: [0.9, 0.7, 0.3], eye: [0.2, 0.2, 0.8], fin: [0.7, 0.6, 0.2] }   // Gold
        ];
        
        // Create the fish in a distributed pattern
        for (let i = 0; i < 10; i++) {
            const fish = new Fish();
            
            // Set gender
            fish.isFemale = i >= 5;
            
            // Set colors
            fish.bodyColor = fishColors[i].body;
            fish.eyeColor = fishColors[i].eye;
            fish.finColor = fishColors[i].fin;
            
            // Position fish in a distributed pattern
            const radius = width * 0.3;
            const angleStep = (Math.PI * 2) / 10;
            const angle = i * angleStep;
            fish.x = width/2 + Math.cos(angle) * radius;
            fish.y = height/2 + Math.sin(angle) * radius;
            
            // Set some with stripes, some with spots
            if (i % 3 === 0) {
                fish.hasStripes = true;
                fish.stripeColor = [Math.random(), Math.random(), Math.random()];
            } else if (i % 3 === 1) {
                fish.hasSpots = true;
                fish.spotColor = [Math.random(), Math.random(), Math.random()];
            }
            
            // Set initial state - first generation starts with food
            fish.attractionThreshold = 0.8; // First generation has lower standards
            fish.foodPoints = 15;  // Start with good amount of food
            fish.canMate = true;   // Ready to mate
            
            fishes.push(fish);
        }
        
        // Create initial sharks
        const maleShark = new Shark();
        maleShark.isFemale = false;
        maleShark.fishEaten = 0;
        maleShark.canMate = false; // Need to eat fish first
        
        const femaleShark = new Shark();
        femaleShark.isFemale = true;
        femaleShark.fishEaten = 0;
        femaleShark.canMate = false; // Need to eat fish first
        
        // Spread them out
        maleShark.x = width * 0.3;
        maleShark.y = height * 0.7;
        femaleShark.x = width * 0.7;
        femaleShark.y = height * 0.7;
        
        sharks.push(maleShark, femaleShark);
        
        // Spawn food
        spawnFood();
    }
    function spawnFood() {
        // Spawn food pellets
        while (totalFoodThisGeneration < FOOD_PER_GENERATION) {
            foodPellets.push(new FoodPellet());
            totalFoodThisGeneration += 5;
        }
    }

    function findFishMate(fish) {
        if (fish.cooldown > 0) return null;
        
        // Must have eaten at least 10 food to mate
        if (!fish.canMate) return null;
        
        // Increase searching time and lower standards gradually
        fish.searchingTime++;
        if (fish.searchingTime > 200) { // Lower standards after searching for a while
            fish.attractionThreshold *= 0.995; // Lower standards gradually
        }
        
        if (fish.isFemale) {
            // Females only pursue males they find very attractive and who can mate
            let bestMale = null;
            let highestScore = -Infinity;
            
            for (const other of fishes) {
                if (!other.isFemale && other.cooldown === 0 && !other.courtingPartner && other.canMate) {
                    const score = fish.evaluateBeauty(other);
                    if (score > highestScore && score >= fish.attractionThreshold) {
                        highestScore = score;
                        bestMale = other;
                    }
                }
            }
            
            // Only pursue if male is sufficiently attractive
            if (bestMale) {
                // Check if other females are also interested
                let competitors = 0;
                for (const otherFemale of fishes) {
                    if (otherFemale !== fish && otherFemale.isFemale && !otherFemale.courtingPartner && otherFemale.canMate) {
                        const otherScore = otherFemale.evaluateBeauty(bestMale);
                        if (otherScore >= otherFemale.attractionThreshold) {
                            competitors++;
                        }
                    }
                }
                
                // If too much competition, might not pursue
                if (competitors > 1 && Math.random() < 0.3) {
                    return null;
                }
            }
            
            return bestMale;
        } else {
            // Males pursue any female they find attractive enough who can mate
            let bestFemale = null;
            let highestScore = -Infinity;
            
            for (const other of fishes) {
                if (other.isFemale && other.cooldown === 0 && !other.courtingPartner && other.canMate) {
                    const score = fish.evaluateBeauty(other);
                    if (score > highestScore && score >= fish.attractionThreshold * 0.5) {
                        highestScore = score;
                        bestFemale = other;
                    }
                }
            }
            
            return bestFemale;
        }
        
        return null;
    }
    function performFishCourtship(fish) {
        const partner = fish.courtingPartner;
        fish.courtingTime++;
        
        // Calculate center point between the two fish
        const centerX = (fish.x + partner.x) / 2;
        const centerY = (fish.y + partner.y) / 2;
        
        // Smaller, more subtle mating dance
        const radius = 15; // Reduced from 30
        const speed = 0.05; // Slower dance
        fish.dancePhase += speed;
        
        // Subtle figure-8 pattern
        const offset = fish.isFemale ? 0 : Math.PI;
        const pattern = Math.sin(fish.dancePhase * 2);
        fish.x = centerX + Math.cos(fish.dancePhase + offset) * radius * (1 + 0.3 * pattern);
        fish.y = centerY + Math.sin(fish.dancePhase + offset) * radius;
        
        // Face each other
        fish.angle = Math.atan2(partner.y - fish.y, partner.x - fish.x);
        
        // After 10 seconds (600 frames at 60fps), check if mating succeeds
        if (fish.courtingTime > 600) {
            if (fish.isFemale && totalFishEggsThisGeneration < MAX_FISH_EGGS) {
                // For first generation, always mate successfully
                let matingSuccess = false;
                if (fishGeneration === 0) {
                    matingSuccess = true;
                } else {
                    // Female might reject the male even after courtship
                    const finalAttraction = fish.evaluateBeauty(partner);
                    matingSuccess = finalAttraction > (fish.attractionThreshold * 1.1); // Increased threshold for stronger selection
                }
                
                if (matingSuccess) {
                    // Female accepts and lays egg
                    fishEggs.push({
                        x: fish.x,
                        y: fish.y,
                        hatchTime: 0,
                        maxHatchTime: 180,
                        parents: [fish, partner]
                    });
                    
                    fish.eggsLaid++;
                    totalFishEggsThisGeneration++;
                    
                    // Shorter cooldown to allow for multiple matings
                    fish.cooldown = 60;
                    partner.cooldown = 30; // Male has shorter cooldown
                    
                    // Reset attraction threshold for next mating
                    fish.attractionThreshold = 1.5;
                    fish.searchingTime = 0;
                } else {
                    // Female rejects after courtship
                    fish.cooldown = 60; // Can try again sooner
                    partner.cooldown = 15; // Male recovers quickly from rejection
                }
            }
            
            // End courtship regardless of outcome
            fish.searchingTime = 0;
            partner.searchingTime = 0;
            fish.courtingPartner = null;
            partner.courtingPartner = null;
        }
    }
    function update() {
        if (isPaused) return;
        
        // Update generation timer
        generationTimer++;
        
        // Check if generation time limit reached
        const generationExpired = generationTimer >= MAX_GENERATION_TIME; 
        const enoughEggs = totalFishEggsThisGeneration >= MAX_FISH_EGGS;
        
        // Start new generation if time expired or enough eggs
        if (generationExpired || enoughEggs) {
            startNewGeneration();
            return;
        }
        
        // Update all fish
        for (let i = fishes.length - 1; i >= 0; i--) {
            const fish = fishes[i];
            
            if (fish.courtingPartner) {
                // If courting, perform mating dance
                performFishCourtship(fish);
            } else {
                // Normal swimming and eating
                fish.update();
            }
            
            // Look for mates only if able and not too many eggs laid
            if (totalFishEggsThisGeneration < MAX_FISH_EGGS && !fish.courtingPartner && fish.canMate) {
                const mate = findFishMate(fish);
                
                if (mate && !mate.courtingPartner) {
                    // Start courtship
                    fish.courtingPartner = mate;
                    mate.courtingPartner = fish;
                    fish.courtingTime = 0;
                    mate.courtingTime = 0;
                }
            }
        }
        
        // Update all sharks
        for (const shark of sharks) {
            shark.update();
        }
        
        // Update fish eggs
        for (let i = fishEggs.length - 1; i >= 0; i--) {
            const egg = fishEggs[i];
            egg.hatchTime++;
            
            if (egg.hatchTime >= egg.maxHatchTime) {
                // Hatch single egg when ready
                fishEggs.splice(i, 1);
                
                // If all eggs have been laid and we're starting a new generation,
                // let startNewGeneration() handle it
                if (totalFishEggsThisGeneration >= MAX_FISH_EGGS) {
                    continue;
                }
                
                // Otherwise hatch this individual egg
                const newFish = new Fish(egg.parents);
                newFish.isFemale = Math.random() < 0.5; // 50/50 gender chance
                newFish.x = egg.x + (Math.random() - 0.5) * 50;
                newFish.y = egg.y + (Math.random() - 0.5) * 50;
                fishes.push(newFish);
            }
        }
        
        // Update shark eggs
        for (let i = sharkEggs.length - 1; i >= 0; i--) {
            const egg = sharkEggs[i];
            egg.hatchTime++;
            
            if (egg.hatchTime >= egg.maxHatchTime) {
                // Hatch single egg when ready
                sharkEggs.splice(i, 1);
                
                // If all eggs have been laid and we're starting a new generation,
                // let startNewGeneration() handle it
                if (totalSharkEggsThisGeneration >= 3) {
                    continue;
                }
                
                // Otherwise hatch this individual egg
                const newShark = new Shark(egg.parents);
                newShark.isFemale = Math.random() < 0.5; // 50/50 gender chance
                newShark.x = egg.x + (Math.random() - 0.5) * 50;
                newShark.y = egg.y + (Math.random() - 0.5) * 50;
                sharks.push(newShark);
            }
        }
    }
    function startNewGeneration() {
        // Increment generation counters
        fishGeneration++;
        
        // Clear old adults
        fishes = [];
        
        // Ensure we have at least FISH_PER_GENERATION eggs/fish
        const availableEggs = fishEggs.length;
        
        // Hatch all eggs at once
        let newFishes = [];
        
        for (let i = 0; i < fishEggs.length; i++) {
            const newFish = new Fish(fishEggs[i].parents);
            newFishes.push(newFish);
        }
        
        // If not enough eggs were laid, create new fish based on surviving eggs
        if (newFishes.length < FISH_PER_GENERATION && newFishes.length > 0) {
            // Clone some existing fish to make up the numbers
            while (newFishes.length < FISH_PER_GENERATION) {
                // Pick random fish from new generation to clone
                const templateFish = newFishes[Math.floor(Math.random() * newFishes.length)];
                const cloneFish = new Fish([templateFish, templateFish]); // Self-crossing
                
                // Add extra mutation to clones
                cloneFish.bodyWidth += (Math.random() - 0.5) * 0.4;
                cloneFish.bodyHeight += (Math.random() - 0.5) * 0.4;
                cloneFish.finSize += (Math.random() - 0.5) * 0.4;
                
                // Randomize colors more
                for (let i = 0; i < 3; i++) {
                    cloneFish.bodyColor[i] = Math.max(0, Math.min(1, cloneFish.bodyColor[i] + (Math.random() - 0.5) * 0.4));
                    cloneFish.finColor[i] = Math.max(0, Math.min(1, cloneFish.finColor[i] + (Math.random() - 0.5) * 0.4));
                    cloneFish.eyeColor[i] = Math.max(0, Math.min(1, cloneFish.eyeColor[i] + (Math.random() - 0.5) * 0.4));
                }
                
                newFishes.push(cloneFish);
            }
        } else if (newFishes.length === 0) {
            // If all fish died with no eggs, create a new starting generation
            createInitialGeneration();
            return;
        }
        
        // Ensure gender balance (close to 50/50)
        const targetFemales = Math.floor(newFishes.length / 2);
        let females = 0;
        
        // Count females
        for (const fish of newFishes) {
            if (fish.isFemale) females++;
        }
        
        // Adjust genders if needed
        if (females !== targetFemales) {
            // Change some fish genders to balance
            const needMore = females < targetFemales;
            const diff = Math.abs(females - targetFemales);
            
            let changed = 0;
            for (const fish of newFishes) {
                if (changed >= diff) break;
                if (fish.isFemale !== needMore) {
                    fish.isFemale = needMore;
                    changed++;
                }
            }
        }
        
        // Position fish around the aquarium
        for (let i = 0; i < newFishes.length; i++) {
            // Spread evenly in a circle
            const angle = (i / newFishes.length) * Math.PI * 2;
            const radius = Math.min(width, height) * 0.3;
            
            newFishes[i].x = width/2 + Math.cos(angle) * radius;
            newFishes[i].y = height/2 + Math.sin(angle) * radius;
            
            // Reset fish state for new generation
            newFishes[i].foodPoints = 0;
            newFishes[i].canMate = false;
            newFishes[i].age = 0;
            newFishes[i].eggsLaid = 0;
        }
        
        // Add new fish to simulation
        fishes = newFishes;
        
        // Clear old eggs
        fishEggs = [];
        totalFishEggsThisGeneration = 0;
        
        // Handle shark generation if needed
        if (totalSharkEggsThisGeneration >= 3) {
            startNewSharkGeneration();
        }
        
        // Reset generation timer
        generationTimer = 0;
        
        // Spawn new food for new generation
        totalFoodThisGeneration = 0;
        foodPellets = [];
        spawnFood();
    }
    
    function startNewSharkGeneration() {
        sharkGeneration++;
        sharks = [];
        
        // Hatch all eggs at once
        for (let i = 0; i < sharkEggs.length; i++) {
            const newShark = new Shark(sharkEggs[i].parents);
            // Ensure gender balance
            newShark.isFemale = i < (sharkEggs.length / 2);
            newShark.x = sharkEggs[i].x + (Math.random() - 0.5) * 50;
            newShark.y = sharkEggs[i].y + (Math.random() - 0.5) * 50;
            
            // Reset shark state
            newShark.fishEaten = 0;
            newShark.canMate = false;
            newShark.age = 0;
            
            sharks.push(newShark);
        }
        
        // If no sharks were born, create new sharks
        if (sharks.length === 0) {
            const maleShark = new Shark();
            maleShark.isFemale = false;
            maleShark.x = width * 0.3;
            maleShark.y = height * 0.7;
            
            const femaleShark = new Shark();
            femaleShark.isFemale = true;
            femaleShark.x = width * 0.7;
            femaleShark.y = height * 0.7;
            
            sharks.push(maleShark, femaleShark);
        }
        
        // Clear old eggs
        sharkEggs = [];
        totalSharkEggsThisGeneration = 0;
    }
    function draw() {
        // Draw dark deep blue background
        ctx.fillStyle = "#000522";
        ctx.fillRect(0, 0, width, height);
        
        // Draw aquarium edges
        ctx.strokeStyle = "#003366";
        ctx.lineWidth = 3;
        ctx.strokeRect(10, 10, width - 20, height - 20);
        
        // Draw food pellets with scent clouds
        for (const food of foodPellets) {
            // Draw scent cloud
            const gradient = ctx.createRadialGradient(food.x, food.y, 0, food.x, food.y, 100);
            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(food.x, food.y, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw food pellet
            food.draw(ctx);
        }
        
        // Draw fish eggs
        for (const egg of fishEggs) {
            const progress = egg.hatchTime / egg.maxHatchTime;
            ctx.fillStyle = `rgba(255, 255, 150, ${0.7 + progress * 0.3})`;
            ctx.beginPath();
            ctx.arc(egg.x, egg.y, 5 + progress * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Egg glow
            ctx.strokeStyle = `rgba(255, 255, 200, ${0.3 - progress * 0.3})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Draw shark eggs
        for (const egg of sharkEggs) {
            const progress = egg.hatchTime / egg.maxHatchTime;
            ctx.fillStyle = `rgba(150, 150, 255, ${0.7 + progress * 0.3})`;
            ctx.beginPath();
            ctx.arc(egg.x, egg.y, 10 + progress * 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Egg glow
            ctx.strokeStyle = `rgba(200, 200, 255, ${0.3 - progress * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // Draw fish
        for (const fish of fishes) {
            fish.draw(ctx);
            
            // Draw heart above courting fish
            if (fish.courtingPartner) {
                ctx.save();
                ctx.translate(fish.x, fish.y - 20);
                ctx.fillStyle = 'rgba(255, 105, 180, 0.8)';
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.bezierCurveTo(-5, -10, -10, -5, -10, 0);
                ctx.bezierCurveTo(-10, 5, -5, 10, 0, 15);
                ctx.bezierCurveTo(5, 10, 10, 5, 10, 0);
                ctx.bezierCurveTo(10, -5, 5, -10, 0, -5);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw food bar for fish
            if (fish.foodPoints > 0) {
                ctx.save();
                ctx.translate(fish.x, fish.y + 15);
                
                // Background bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-15, 0, 30, 3);
                
                // Food bar
                const foodBarWidth = Math.min(30, (fish.foodPoints / 40) * 30);
                ctx.fillStyle = fish.foodPoints >= 10 ? '#00ff00' : '#ffff00';
                ctx.fillRect(-15, 0, foodBarWidth, 3);
                
                ctx.restore();
            }
        }
        
        // Draw sharks
        for (const shark of sharks) {
            shark.draw(ctx);
            
            // Draw heart above courting sharks
            if (shark.courtingPartner) {
                ctx.save();
                ctx.translate(shark.x, shark.y - 35);
                ctx.fillStyle = 'rgba(255, 105, 180, 0.8)';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.bezierCurveTo(-8, -16, -16, -8, -16, 0);
                ctx.bezierCurveTo(-16, 8, -8, 16, 0, 24);
                ctx.bezierCurveTo(8, 16, 16, 8, 16, 0);
                ctx.bezierCurveTo(16, -8, 8, -16, 0, -8);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw fish eaten indicator for sharks
            if (shark.fishEaten > 0) {
                ctx.save();
                ctx.translate(shark.x, shark.y + 25);
                
                // Background bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-20, 0, 40, 5);
                
                // Fish eaten bar
                const barWidth = (shark.fishEaten / 2) * 40;
                ctx.fillStyle = shark.fishEaten >= 1 ? '#ff4444' : '#ff8888';
                ctx.fillRect(-20, 0, barWidth, 5);
                
                ctx.restore();
            }
        }
        
        // Draw generation timer
        const timeLeft = MAX_GENERATION_TIME - generationTimer;
        const timePercentage = timeLeft / MAX_GENERATION_TIME;
        
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(width/2 - 100, 15, 200, 10);
        
        // Timer bar
        ctx.fillStyle = `rgb(${Math.floor(255 * (1-timePercentage))}, ${Math.floor(255 * timePercentage)}, 0)`;
        ctx.fillRect(width/2 - 100, 15, 200 * timePercentage, 10);
        ctx.restore();
        
        // Update info panel
        updateInfoPanel();
    }
    function updateInfoPanel() {
        const infoDiv = document.getElementById('info');
        let html = `<div style="font-size: 16px; margin-bottom: 5px;">Fish Generation: ${fishGeneration}</div>`;
        html += `<div style="font-size: 16px; margin-bottom: 10px;">Shark Generation: ${sharkGeneration}</div>`;
        
        // Generation timer
        const timePercentage = Math.floor((MAX_GENERATION_TIME - generationTimer) / MAX_GENERATION_TIME * 100);
        html += `<div>Generation Time: ${timePercentage}%</div>`;
        
        html += `<div>Fish Eggs: ${totalFishEggsThisGeneration}/${MAX_FISH_EGGS}</div>`;
        html += `<div>Shark Eggs: ${totalSharkEggsThisGeneration}/3</div>`;
        html += `<div>Food Available: ${foodPellets.length * 5}</div>`;
        
        // Fish stats
        html += `<div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 5px; font-weight: bold;">Fish Stats:</div>`;
        
        // Fish counts
        const hungryFishCount = fishes.filter(f => !f.canMate).length;
        const searchingFishCount = fishes.filter(f => f.searchingTime > 100 && !f.courtingPartner && f.canMate).length;
        const courtingFishCount = fishes.filter(f => f.courtingPartner).length;
        
        html += `<div>Total Fish: ${fishes.length}</div>`;
        html += `<div>Hungry Fish: ${hungryFishCount}</div>`;
        if (searchingFishCount > 0) {
            html += `<div>Searching: ${searchingFishCount}</div>`;
        }
        if (courtingFishCount > 0) {
            html += `<div>Courting: ${courtingFishCount}</div>`;
        }
        
        // Female fish stats
        html += `<div style="margin-top: 5px;"><u>Female Fish:</u></div>`;
        
        let femaleFishIndex = 0;
        for (const fish of fishes) {
            if (fish.isFemale) {
                html += `<div>Female ${femaleFishIndex + 1}: ${fish.eggsLaid} eggs, ${fish.foodPoints} food</div>`;
                femaleFishIndex++;
                if (femaleFishIndex > 4) {
                    html += `<div>... and ${fishes.filter(f => f.isFemale).length - 5} more</div>`;
                    break;
                }
            }
        }
        
        // Male fish stats
        html += `<div style="margin-top: 5px;"><u>Male Fish:</u></div>`;
        
        let maleFishIndex = 0;
        for (const fish of fishes) {
            if (!fish.isFemale) {
                html += `<div>Male ${maleFishIndex + 1}: ${fish.foodPoints} food</div>`;
                maleFishIndex++;
                if (maleFishIndex > 4) {
                    html += `<div>... and ${fishes.filter(f => !f.isFemale).length - 5} more</div>`;
                    break;
                }
            }
        }
        
        // Shark stats
        html += `<div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 5px; font-weight: bold;">Shark Stats:</div>`;
        
        // Shark counts
        const huntingSharks = sharks.filter(s => s.targetFish).length;
        const courtingSharks = sharks.filter(s => s.courtingPartner).length;
        const restingSharks = sharks.filter(s => s.huntingCooldown > 0).length;
        
        html += `<div>Total Sharks: ${sharks.length}</div>`;
        if (huntingSharks > 0) {
            html += `<div>Hunting: ${huntingSharks}</div>`;
        }
        if (courtingSharks > 0) {
            html += `<div>Courting: ${courtingSharks}</div>`;
        }
        if (restingSharks > 0) {
            html += `<div>Resting: ${restingSharks}</div>`;
        }
        
        // Female shark stats
        html += `<div style="margin-top: 5px;"><u>Female Sharks:</u></div>`;
        
        let femaleSharkIndex = 0;
        for (const shark of sharks) {
            if (shark.isFemale) {
                html += `<div>Female ${femaleSharkIndex + 1}: ${shark.eggsLaid} eggs, ${shark.fishEaten} fish eaten</div>`;
                femaleSharkIndex++;
            }
        }
        
        // Male shark stats
        html += `<div style="margin-top: 5px;"><u>Male Sharks:</u></div>`;
        
        let maleSharkIndex = 0;
        for (const shark of sharks) {
            if (!shark.isFemale) {
                html += `<div>Male ${maleSharkIndex + 1}: ${shark.fishEaten} fish eaten</div>`;
                maleSharkIndex++;
            }
        }
        
        infoDiv.innerHTML = html;
    }
    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }

    document.getElementById("resetBtn").addEventListener("click", () => {
        fishGeneration = 0;
        sharkGeneration = 0;
        createInitialGeneration();
    });
    
    document.getElementById("pauseBtn").addEventListener("click", () => {
        isPaused = !isPaused;
        document.getElementById("pauseBtn").textContent = isPaused ? "Resume" : "Pause";
    });

    window.addEventListener("resize", () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    });

    createInitialGeneration();
    animate();
</script>
</body>
</html>
