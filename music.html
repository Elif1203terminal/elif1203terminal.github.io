<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ðŸŽ¼ Elif Composer (Final Build)</title>
  <style>
    body {
      background: #000;
      color: #33ff33;
      font-family: 'Courier New', monospace;
      padding: 20px;
    }
    textarea, select, button {
      width: 100%;
      background: #111;
      color: #33ff33;
      border: 1px solid #33ff33;
      padding: 10px;
      margin: 10px 0;
    }
    canvas {
      background: #111;
      margin-top: 20px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@1.2.93/releases/vexflow-min.js"></script>
  <script src="https://unpkg.com/tone@14.8.39/build/Tone.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/audio-buffer-to-wav/index.min.js"></script>
</head>
<body>
  <h2>ðŸŽ¼ Elif Music Composer</h2>

  <label>Enter JSON Score:</label>
  <textarea id="notation" rows="10">{
  "treble": [
    { "note": "C5", "duration": "4n" },
    { "note": "E5", "duration": "8n" },
    { "note": "G5", "duration": "8n" },
    { "note": "A5", "duration": "2n" }
  ],
  "bass": [
    { "note": "C3", "duration": "1n" },
    { "note": "F2", "duration": "1n" }
  ]
}</textarea>

  <label>Instrument:</label>
  <select id="instrument">
    <option value="Synth">ðŸŽ¹ Synth</option>
    <option value="AMSynth">ðŸŒ™ AMSynth</option>
    <option value="FMSynth">ðŸ”Š FMSynth</option>
  </select>

  <button onclick="renderScore()">â–¶ Render & Play</button>
  <button onclick="exportWav()">ðŸ’¾ Export WAV</button>

  <div id="sheet"></div>

  <script>
    const VF = Vex.Flow;
    let latestScore = { treble: [], bass: [] };

    function durationToBeats(d) {
      return { "1n": 4, "2n": 2, "4n": 1, "8n": 0.5 }[d] || 1;
    }

    function noteToVF(note) {
      const m = note.match(/([A-G][#b]?)(\d)/);
      return m ? `${m[1].toLowerCase()}/${m[2]}` : "b/4";
    }

    function parseScore() {
      try {
        const input = JSON.parse(document.getElementById("notation").value);
        latestScore = input;
        return input;
      } catch (e) {
        alert("Invalid JSON");
        throw e;
      }
    }

    function renderScore() {
      Tone.start(); // Ensure audio context is resumed
      const score = parseScore();
      const sheet = document.getElementById("sheet");
      sheet.innerHTML = '';
      const renderer = new VF.Renderer(sheet, VF.Renderer.Backends.SVG);
      renderer.resize(900, 400);
      const context = renderer.getContext();

      const trebleStave = new VF.Stave(10, 40, 800).addClef("treble").addTimeSignature("4/4");
      const bassStave = new VF.Stave(10, 140, 800).addClef("bass").addTimeSignature("4/4");
      trebleStave.setContext(context).draw();
      bassStave.setContext(context).draw();

      const trebleTicks = score.treble.reduce((sum, n) => sum + VF.durationToTicks(n.duration.replace('n', '')), 0);
      const bassTicks = score.bass.reduce((sum, n) => sum + VF.durationToTicks(n.duration.replace('n', '')), 0);

      const trebleVoice = new VF.Voice({ num_beats: trebleTicks / 1024, beat_value: 4 });
      const bassVoice = new VF.Voice({ num_beats: bassTicks / 1024, beat_value: 4 });

      trebleVoice.addTickables(score.treble.map(n => new VF.StaveNote({ keys: [noteToVF(n.note)], duration: n.duration.replace('n', '') })));
      bassVoice.addTickables(score.bass.map(n => new VF.StaveNote({ keys: [noteToVF(n.note)], duration: n.duration.replace('n', '') })));

      new VF.Formatter().joinVoices([trebleVoice, bassVoice]).format([trebleVoice, bassVoice], 750);
      trebleVoice.draw(context, trebleStave);
      bassVoice.draw(context, bassStave);

      playNow(score);
    }

    function playNow(score) {
      const inst = document.getElementById("instrument").value;
      const Synth = Tone[inst] || Tone.Synth;
      const synthT = new Synth().toDestination();
      const synthB = new Synth().toDestination();
      let t = Tone.now();

      score.treble.forEach(n => {
        synthT.triggerAttackRelease(n.note, n.duration, t);
        t += Tone.Time(n.duration).toSeconds();
      });

      t = Tone.now();
      score.bass.forEach(n => {
        synthB.triggerAttackRelease(n.note, n.duration, t);
        t += Tone.Time(n.duration).toSeconds();
      });
    }

    async function exportWav() {
      const inst = document.getElementById("instrument").value;
      const Synth = Tone[inst] || Tone.Synth;
      const score = latestScore;

      const buffer = await Tone.Offline(({ transport }) => {
        const synthT = new Synth().toDestination();
        const synthB = new Synth().toDestination();
        let t = 0;
        score.treble.forEach(n => {
          synthT.triggerAttackRelease(n.note, n.duration, t);
          t += Tone.Time(n.duration).toSeconds();
        });
        t = 0;
        score.bass.forEach(n => {
          synthB.triggerAttackRelease(n.note, n.duration, t);
          t += Tone.Time(n.duration).toSeconds();
        });
        transport.start();
      }, 20);

      const wav = audioBufferToWav(buffer.get());
      const blob = new Blob([wav], { type: "audio/wav" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "elif_song.wav";
      a.click();
    }
  </script>
</body>
</html>








