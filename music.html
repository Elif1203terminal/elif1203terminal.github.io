<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ðŸŽ¼ Elif Music Composer (Structured Input)</title>
  <style>
    body {
      background: #000;
      color: #33ff33;
      font-family: 'Courier New', monospace;
      padding: 20px;
    }
    textarea, select, button {
      width: 100%;
      background: #111;
      color: #33ff33;
      border: 1px solid #33ff33;
      padding: 10px;
      margin: 10px 0;
    }
    canvas {
      background: #111;
      margin-top: 20px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@1.2.93/releases/vexflow-min.js"></script>
  <script src="https://unpkg.com/tone@14.8.39/build/Tone.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/audio-buffer-to-wav/index.min.js"></script>
</head>
<body>
  <h2>ðŸŽ¼ Elif Music Composer</h2>

  <label>Enter JSON Score:</label>
  <textarea id="notation" rows="10">{
  "treble": [
    { "note": "C5", "duration": "4n" },
    { "note": "E5", "duration": "8n" },
    { "note": "G5", "duration": "8n" },
    { "note": "A5", "duration": "2n" }
  ],
  "bass": [
    { "note": "C3", "duration": "1n" },
    { "note": "F2", "duration": "1n" }
  ]
}</textarea>

  <label>Instrument:</label>
  <select id="instrument">
    <option value="Synth">ðŸŽ¹ Synth</option>
    <option value="AMSynth">ðŸŒ™ AMSynth</option>
    <option value="FMSynth">ðŸ”Š FMSynth</option>
  </select>

  <button onclick="render()">â–¶ Render & Play</button>
  <button onclick="exportWav()">ðŸ’¾ Export WAV</button>

  <div id="sheet"></div>

  <script>
    const VF = Vex.Flow;
    let latestScore = { treble: [], bass: [] };

    function durationToTicks(duration) {
      const mapping = { "1n": 4, "2n": 2, "4n": 1, "8n": 0.5 };
      return mapping[duration] || 1;
    }

    function noteToVex(note) {
      const m = note.match(/([A-G][#b]?)(\d)/);
      return m ? `${m[1].toLowerCase()}/${m[2]}` : "b/4";
    }

    function parseJSON() {
      try {
        const input = document.getElementById("notation").value.trim();
        const data = JSON.parse(input);
        latestScore = data;
        return data;
      } catch (e) {
        alert("Invalid JSON format");
        throw e;
      }
    }

    function buildVFVoice(notes) {
      return notes.map(n => new VF.StaveNote({
        keys: [noteToVex(n.note)],
        duration: n.duration.replace("n", "")
      }));
    }

    function render() {
      const data = parseJSON();
      const sheet = document.getElementById("sheet");
      sheet.innerHTML = '';

      const renderer = new VF.Renderer(sheet, VF.Renderer.Backends.SVG);
      renderer.resize(900, 400);
      const context = renderer.getContext();

      const staveT = new VF.Stave(10, 40, 800).addClef("treble").addTimeSignature("4/4");
      const staveB = new VF.Stave(10, 140, 800).addClef("bass").addTimeSignature("4/4");

      staveT.setContext(context).draw();
      staveB.setContext(context).draw();

      const voiceT = new VF.Voice({ num_beats: 16, beat_value: 4, resolution: VF.RESOLUTION });
      const voiceB = new VF.Voice({ num_beats: 16, beat_value: 4, resolution: VF.RESOLUTION });

      voiceT.addTickables(buildVFVoice(data.treble));
      voiceB.addTickables(buildVFVoice(data.bass));

      new VF.Formatter().joinVoices([voiceT, voiceB]).format([voiceT, voiceB], 750);
      voiceT.draw(context, staveT);
      voiceB.draw(context, staveB);

      playNow(data);
    }

    function playNow(data) {
      const inst = document.getElementById("instrument").value;
      const Synth = Tone[inst] || Tone.Synth;
      const synthT = new Synth().toDestination();
      const synthB = new Synth().toDestination();
      let t = Tone.now();

      data.treble.forEach(n => {
        synthT.triggerAttackRelease(n.note, n.duration, t);
        t += Tone.Time(n.duration).toSeconds();
      });

      t = Tone.now();
      data.bass.forEach(n => {
        synthB.triggerAttackRelease(n.note, n.duration, t);
        t += Tone.Time(n.duration).toSeconds();
      });
    }

    async function exportWav() {
      const inst = document.getElementById("instrument").value;
      const Synth = Tone[inst] || Tone.Synth;
      const data = latestScore;

      const buffer = await Tone.Offline(({ transport }) => {
        const synthT = new Synth().toDestination();
        const synthB = new Synth().toDestination();
        let t = 0;
        data.treble.forEach(n => {
          synthT.triggerAttackRelease(n.note, n.duration, t);
          t += Tone.Time(n.duration).toSeconds();
        });
        t = 0;
        data.bass.forEach(n => {
          synthB.triggerAttackRelease(n.note, n.duration, t);
          t += Tone.Time(n.duration).toSeconds();
        });
        transport.start();
      }, 10); // Render 10 seconds max

      const wav = audioBufferToWav(buffer.get());
      const blob = new Blob([wav], { type: "audio/wav" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "elif_score.wav";
      a.click();
    }
  </script>
</body>
</html>








