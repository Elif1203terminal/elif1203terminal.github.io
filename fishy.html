<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Evolutionary Fish Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000033; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 200px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
        }
        .control-button {
            padding: 8px 16px;
            margin: 5px;
            background: rgba(0,100,200,0.8);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        .control-button:hover {
            background: rgba(0,150,255,0.9);
        }
        #control-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(0,20,40,0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 300px;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        .slider-container input {
            width: 100%;
        }
        .slider-value {
            display: inline-block;
            width: 40px;
            text-align: right;
            margin-left: 10px;
        }
        .beauty-visualization {
            position: absolute;
            padding: 10px;
            border-radius: 5px;
            background: rgba(0,0,0,0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            color: white;
            max-width: 200px;
            text-align: center;
        }
        #beauty-indicator {
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, blue, purple, red, orange, yellow);
            margin-top: 5px;
            border-radius: 4px;
        }
        #beauty-pointer {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 10px solid white;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: -2px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info-panel">
        <h3>Fish Evolution</h3>
        <div id="stats"></div>
    </div>
    
    <div id="controls">
        <button id="pauseBtn" class="control-button">Pause</button>
        <button id="resetBtn" class="control-button">Reset</button>
    </div>
    
    <div id="control-panel">
        <h2>Simulation Controls</h2>
        
        <div class="slider-container">
            <label for="mutationRate">Mutation Rate: <span id="mutationRateValue" class="slider-value">0.05</span></label>
            <input type="range" id="mutationRate" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>
        
        <div class="slider-container">
            <label for="beautyEvolutionRate">Beauty Evolution Rate: <span id="beautyEvolutionRateValue" class="slider-value">0.10</span></label>
            <input type="range" id="beautyEvolutionRate" min="0.05" max="0.3" step="0.01" value="0.10">
        </div>
        
        <div class="slider-container">
            <label for="fishCount">Max Fish Count: <span id="fishCountValue" class="slider-value">12</span></label>
            <input type="range" id="fishCount" min="6" max="30" step="2" value="12">
        </div>
        
        <div class="slider-container">
            <label for="foodPerGeneration">Food Per Generation: <span id="foodPerGenerationValue" class="slider-value">90</span></label>
            <input type="range" id="foodPerGeneration" min="60" max="200" step="10" value="90">
        </div>
        
        <div class="slider-container">
            <label for="learningRate">Learning Rate: <span id="learningRateValue" class="slider-value">0.05</span></label>
            <input type="range" id="learningRate" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>
        
        <button id="applyBtn" class="control-button">Apply & Resume</button>
    </div>
    
    <div id="beauty-visualization" class="beauty-visualization">
        <div>Beauty Preference</div>
        <div id="beauty-pointer"></div>
        <div id="beauty-indicator"></div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    // Simulation parameters - these can be modified via control panel
    let CONFIG = {
        mutationRate: 0.05,
        beautyEvolutionRate: 0.10,
        maxFishCount: 12,
        foodPerGeneration: 90,
        learningRate: 0.05
    };
    
    // Simulation state
    let paused = false;
    let showFishDetails = false;
    let selectedFish = null;
    
    class Fish {
        constructor(parents = null) {
            // Physical traits
            this.bodyWidth = 0.8 + Math.random() * 0.4;
            this.bodyHeight = 0.8 + Math.random() * 0.4;
            this.eyeSize = 0.1 + Math.random() * 0.2;
            this.finSize = 0.3 + Math.random() * 0.4;
            this.symmetry = 0.8 + Math.random() * 0.4;
            
            // Color traits 
            this.bodyColor = [Math.random(), Math.random(), Math.random()];
            this.eyeColor = [Math.random(), Math.random(), Math.random()];
            this.finColor = [Math.random(), Math.random(), Math.random()];
            
            // Position & movement
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = 1 + Math.random() * 0.5;
            
            // Beauty preferences - expanded to be more diverse and detailed
            this.beautyWeights = {
                symmetry: 0.5 + Math.random() * 1.0,
                eyeSize: 0.5 + Math.random() * 1.0,
                finSize: 0.5 + Math.random() * 1.0,
                bodyShape: 0.5 + Math.random() * 1.0,
                colorVibrancy: 0.5 + Math.random() * 1.0,
                bodyColor: [Math.random(), Math.random(), Math.random()], // Preferred body color
                finColor: [Math.random(), Math.random(), Math.random()],  // Preferred fin color
                eyeColor: [Math.random(), Math.random(), Math.random()],  // Preferred eye color
                size: 0.5 + Math.random() * 1.0                           // Preferred overall size
            };
            
            // Breeding state
            this.isFemale = Math.random() < 0.5;
            this.hasMated = false;
            this.eggsLaid = 0;
            this.cooldown = 0;
            this.searchingTime = 0;
            this.preferredMate = null;
            this.attractionThreshold = 1.5; // Lower initial threshold
            this.courtingPartner = null;
            this.courtingTime = 0;
            this.dancePhase = 0;
            this.breedingSuccess = 0.5 + Math.random() * 0.5; // Genetic breeding ability
            
            // Food and energy system
            this.foodPoints = 0;
            this.hunger = 0;
            this.targetFood = null;
            this.canMate = false;
            
            // Food finding abilities (evolvable traits)
            this.visionRange = 30 + Math.random() * 70; // Visual detection range
            this.visionAngle = Math.PI / 4 + Math.random() * Math.PI / 2; // Field of view
            this.smellSensitivity = 0.01 + Math.random() * 0.09; // How well they detect faint scents
            this.foodSpeed = 0.8 + Math.random() * 0.4; // Speed boost when hunting
            
            // Hunting strategy (0-1, where 0 = vision-based, 1 = smell-based)
            this.huntingStrategy = Math.random();
            
            // Learning and memory
            this.memory = {
                successfulFoodSpots: [], // Remembers where food was found
                successfulMates: [], // Remembers which fish had successful matings
                observations: [] // General observations about environment
            };
            this.learningAbility = 0.5 + Math.random() * 0.5; // How quickly they learn
            
            // Social behavior
            this.socialTendency = Math.random(); // 0 = loner, 1 = very social
            this.leadFollowTendency = Math.random(); // 0 = follower, 1 = leader
            
            // Age and lifespan
            this.age = 0;
            this.ageSpeedFactor = 1.0; // Aging speed multiplier
            
            // Beauty display traits (how they show off to potential mates)
            this.displayBehavior = Math.floor(Math.random() * 3); // 0 = dance, 1 = color flash, 2 = fin display
            this.displayIntensity = 0.5 + Math.random() * 0.5;
            
            // Generate unique ID for this fish
            this.id = Math.random().toString(36).substr(2, 9);
            
            if (parents) this.inheritTraits(parents);
        }

        inheritTraits(parents) {
            // Mutation rate from config
            const mutationRate = CONFIG.mutationRate;
            const beautyEvolutionRate = CONFIG.beautyEvolutionRate;
            
            // Inherit physical traits with mutation
            this.bodyWidth = this.inheritTrait(parents[0].bodyWidth, parents[1].bodyWidth, mutationRate);
            this.bodyHeight = this.inheritTrait(parents[0].bodyHeight, parents[1].bodyHeight, mutationRate);
            this.eyeSize = this.inheritTrait(parents[0].eyeSize, parents[1].eyeSize, mutationRate);
            this.finSize = this.inheritTrait(parents[0].finSize, parents[1].finSize, mutationRate);
            this.symmetry = this.inheritTrait(parents[0].symmetry, parents[1].symmetry, mutationRate);
            
            // Inherit color traits with mutation
            for (let i = 0; i < 3; i++) {
                this.bodyColor[i] = this.inheritTrait(parents[0].bodyColor[i], parents[1].bodyColor[i], mutationRate);
                this.eyeColor[i] = this.inheritTrait(parents[0].eyeColor[i], parents[1].eyeColor[i], mutationRate);
                this.finColor[i] = this.inheritTrait(parents[0].finColor[i], parents[1].finColor[i], mutationRate);
            }
            
            // Inherit beauty preferences with mutation - higher rate for faster evolution
            for (const key in this.beautyWeights) {
                if (Array.isArray(this.beautyWeights[key])) {
                    // For color preferences
                    for (let i = 0; i < 3; i++) {
                        this.beautyWeights[key][i] = this.inheritTrait(
                            parents[0].beautyWeights[key][i], 
                            parents[1].beautyWeights[key][i], 
                            beautyEvolutionRate
                        );
                    }
                } else {
                    // For numeric preferences
                    this.beautyWeights[key] = this.inheritTrait(
                        parents[0].beautyWeights[key], 
                        parents[1].beautyWeights[key], 
                        beautyEvolutionRate
                    );
                }
            }
            
            // Inherit food-finding abilities
            this.visionRange = this.inheritTrait(parents[0].visionRange, parents[1].visionRange, mutationRate);
            this.visionAngle = this.inheritTrait(parents[0].visionAngle, parents[1].visionAngle, mutationRate);
            this.smellSensitivity = this.inheritTrait(parents[0].smellSensitivity, parents[1].smellSensitivity, mutationRate);
            this.foodSpeed = this.inheritTrait(parents[0].foodSpeed, parents[1].foodSpeed, mutationRate);
            this.huntingStrategy = this.inheritTrait(parents[0].huntingStrategy, parents[1].huntingStrategy, mutationRate);
            
            // Inherit learning and behavior traits
            this.learningAbility = this.inheritTrait(parents[0].learningAbility, parents[1].learningAbility, mutationRate);
            this.socialTendency = this.inheritTrait(parents[0].socialTendency, parents[1].socialTendency, mutationRate);
            this.leadFollowTendency = this.inheritTrait(parents[0].leadFollowTendency, parents[1].leadFollowTendency, mutationRate);
            this.breedingSuccess = this.inheritTrait(parents[0].breedingSuccess, parents[1].breedingSuccess, mutationRate * 0.5); // More stable
            
            // Inherit display behavior with possible mutation
            if (Math.random() < mutationRate) {
                this.displayBehavior = Math.floor(Math.random() * 3);
            } else {
                this.displayBehavior = Math.random() < 0.5 ? parents[0].displayBehavior : parents[1].displayBehavior;
            }
            this.displayIntensity = this.inheritTrait(parents[0].displayIntensity, parents[1].displayIntensity, mutationRate);
        }

        inheritTrait(parent1Trait, parent2Trait, mutationRate) {
            // Base inheritance - blend of parents with possible dominance
            let dominanceFactor = Math.random();
            let inherited = parent1Trait * dominanceFactor + parent2Trait * (1 - dominanceFactor);
            
            // Apply mutation
            if (Math.random() < mutationRate) {
                // Mutation strength proportional to the trait's value
                const mutationStrength = 0.2;
                inherited += (Math.random() - 0.5) * mutationStrength * inherited;
            }
            
            // Keep values reasonable - add min/max constraints but allow for occasional extraordinary traits
            if (Math.random() < 0.05) { // 5% chance of extraordinary trait
                return Math.max(0.1, Math.min(3.0, inherited));
            } else {
                return Math.max(0.1, Math.min(2.0, inherited));
            }
        }

        evaluateBeauty(other) {
            let score = 0;
            
            // Basic physical traits evaluation
            score += this.beautyWeights.symmetry * other.symmetry;
            score += this.beautyWeights.eyeSize * other.eyeSize;
            score += this.beautyWeights.finSize * other.finSize;
            
            // Body shape preference (ideal ratio)
            const bodyRatio = other.bodyWidth / other.bodyHeight;
            const idealRatio = 1.5; 
            score += this.beautyWeights.bodyShape * (1 - Math.abs(idealRatio - bodyRatio));
            
            // Size preference
            const totalSize = other.bodyWidth * other.bodyHeight;
            score += this.beautyWeights.size * (1 - Math.abs(1.0 - totalSize));
            
            // Color preference - how close colors are to preferred colors
            const bodyColorMatch = this.colorSimilarity(this.beautyWeights.bodyColor, other.bodyColor);
            const finColorMatch = this.colorSimilarity(this.beautyWeights.finColor, other.finColor);
            const eyeColorMatch = this.colorSimilarity(this.beautyWeights.eyeColor, other.eyeColor);
            score += bodyColorMatch * 0.6;
            score += finColorMatch * 0.2;
            score += eyeColorMatch * 0.2;
            
            // Color vibrancy (how saturated the colors are)
            const colorVibrancy = this.calculateColorVibrancy(other.bodyColor);
            score += this.beautyWeights.colorVibrancy * colorVibrancy;
            
            // Display behavior preference
            // Fish are more attracted to those with similar display behaviors
            const displayMatch = 1 - Math.abs(this.displayBehavior - other.displayBehavior) / 3;
            score += displayMatch * 0.5;
            
            // Well-fed fish are more attractive (good providers/resourceful)
            if (other.foodPoints > 10) {
                score *= 1 + (other.foodPoints - 10) * 0.01; // Max 30% boost at 40 food points
            }
            
            // Breeding success makes a fish more attractive (proven genetics)
            if (other.eggsLaid > 0 || other.hasMated) {
                score *= 1 + other.breedingSuccess * 0.2; // Up to 20% boost
            }
            
            // Learning ability is slightly attractive (smarter fish)
            score *= 1 + other.learningAbility * 0.1;
            
            // Social compatibility - similar social tendencies are slightly preferred
            const socialCompatibility = 1 - Math.abs(this.socialTendency - other.socialTendency);
            score *= 1 + socialCompatibility * 0.1;
            
            return score;
        }

        colorSimilarity(color1, color2) {
            // Calculate how similar two colors are (0-1)
            let similarity = 0;
            for (let i = 0; i < 3; i++) {
                similarity += 1 - Math.abs(color1[i] - color2[i]);
            }
            return similarity / 3; // Average across RGB channels
        }

        calculateColorVibrancy(color) {
            const max = Math.max(...color);
            const min = Math.min(...color);
            return (max - min);
        }

        learn(observation, type) {
            // Fish learn from observations based on their learning ability
            if (Math.random() < this.learningAbility * CONFIG.learningRate) {
                // Limit memory size to prevent performance issues
                if (this.memory[type].length >= 5) {
                    this.memory[type].shift(); // Remove oldest memory
                }
                
                // Add new observation to memory
                this.memory[type].push(observation);
                
                // Return true if learning was successful
                return true;
            }
            return false;
        }

        getMemory(type) {
            // Retrieve memory of specified type, or null if none exists
            if (this.memory[type] && this.memory[type].length > 0) {
                // Weight recent memories more strongly
                const index = Math.floor(Math.random() * Math.random() * this.memory[type].length);
                return this.memory[type][index];
            }
            return null;
        }

        update() {
            if (paused) return;
            
            if (this.cooldown > 0) this.cooldown--;
            this.age += 0.01 * this.ageSpeedFactor;
            
            // Social learning - observe other fish's behavior
            this.observeOtherFish();
            
            // Find food if not yet able to mate
            if (!this.canMate && !this.targetFood) {
                this.findFood();
            }
            
            // Move towards food if hunting, or towards mate if courting,
            // otherwise normal swimming
            if (this.targetFood && !this.canMate) {
                this.moveTowardsFood();
            } else if (this.courtingPartner) {
                // Do nothing - courtship movement handled in performCourtship
            } else {
                this.swim();
            }
            
            // Stay within boundaries
            this.enforceBoundaries();
        }
        
        observeOtherFish() {
            // Observe successful fish nearby and learn from them
            if (Math.random() < 0.05 * this.learningAbility) {
                // Find nearby fish to observe
                for (const other of fishes) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only observe fish within vision range
                    if (dist < this.visionRange) {
                        // Learn from successful hunters
                        if (other.foodPoints > this.foodPoints + 10) {
                            // Adjust hunting strategy slightly towards observed fish
                            const learningStrength = 0.1 * this.learningAbility;
                            this.huntingStrategy += (other.huntingStrategy - this.huntingStrategy) * learningStrength;
                            
                            // Maybe adjust vision/smell parameters
                            if (Math.random() < this.learningAbility) {
                                this.visionRange += (other.visionRange - this.visionRange) * learningStrength;
                                this.smellSensitivity += (other.smellSensitivity - this.smellSensitivity) * learningStrength;
                            }
                            
                            this.learn({ 
                                id: other.id,
                                strategy: other.huntingStrategy,
                                success: other.foodPoints
                            }, 'observations');
                        }
                        
                        // Learn from successful breeders
                        if (other.eggsLaid > 0 && this.isFemale) {
                            // Learn about beauty preferences from successful females
                            const learningStrength = 0.05 * this.learningAbility;
                            for (const key in this.beautyWeights) {
                                if (typeof this.beautyWeights[key] === 'number') {
                                    this.beautyWeights[key] += (other.beautyWeights[key] - this.beautyWeights[key]) * learningStrength;
                                }
                            }
                            
                            this.learn({
                                id: other.id,
                                eggsLaid: other.eggsLaid,
                                beautyPreferences: { ...other.beautyWeights }
                            }, 'successfulMates');
                        }
                    }
                }
            }
        }
        
        findFood() {
            let bestFood = null;
            let bestScore = -Infinity;
            
            // Check if there's a remembered food spot to try
            const foodMemory = this.getMemory('successfulFoodSpots');
            if (foodMemory && Math.random() < this.learningAbility) {
                // Check if any food is near the remembered spot
                for (const food of foodPellets) {
                    const distToMemory = Math.sqrt(
                        Math.pow(food.x - foodMemory.x, 2) + 
                        Math.pow(food.y - foodMemory.y, 2)
                    );
                    
                    if (distToMemory < 100) { // If food is near remembered spot
                        bestFood = food;
                        break;
                    }
                }
            }
            
            // If no remembered spot or no food found there, use normal detection
            if (!bestFood) {
                for (const food of foodPellets) {
                    const dx = food.x - this.x;
                    const dy = food.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if can detect food
                    let canDetect = false;
                    let detectionScore = 0;
                    
                    // Visual detection (directional)
                    const angleToFood = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angleToFood - this.angle);
                    const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                    
                    if (dist < this.visionRange && normalizedAngleDiff < this.visionAngle / 2) {
                        canDetect = true;
                        detectionScore = (1 - dist / this.visionRange) * (1 - this.huntingStrategy);
                    }
                    
                    // Smell detection (based on scent strength)
                    const scentStrength = food.getScentStrengthAt(this.x, this.y);
                    if (scentStrength > this.smellSensitivity) {
                        canDetect = true;
                        const smellScore = scentStrength * this.huntingStrategy;
                        detectionScore = Math.max(detectionScore, smellScore);
                    }
                    
                    // Choose the best detected food
                    if (canDetect && detectionScore > bestScore) {
                        bestScore = detectionScore;
                        bestFood = food;
                    }
                }
            }
            
            // Set target food
            this.targetFood = bestFood;
        }
        
        moveTowardsFood() {
            const dx = this.targetFood.x - this.x;
            const dy = this.targetFood.y - this.y;
            this.angle = Math.atan2(dy, dx);
            
            // Check if reached food
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 10) {
                this.foodPoints += this.targetFood.value;
                
                // Remember this spot as good for food
                this.learn({
                    x: this.targetFood.x,
                    y: this.targetFood.y,
                    value: this.targetFood.value
                }, 'successfulFoodSpots');
                
                // Remove the food pellet
                const index = foodPellets.indexOf(this.targetFood);
                if (index > -1) {
                    foodPellets.splice(index, 1);
                }
                this.targetFood = null;
                
                // Check if can mate now
                if (this.foodPoints >= 10) {
                    this.canMate = true;
                }
            }
            
            // Move faster when hunting food
            this.x += Math.cos(this.angle) * this.speed * this.foodSpeed;
            this.y += Math.sin(this.angle) * this.speed * this.foodSpeed;
        }
        
        swim() {
            // Normal swimming behavior
            this.wanderAngle = this.wanderAngle || 0;
            this.wanderAngle += (Math.random() - 0.5) * 0.3;
            this.angle += Math.sin(this.wanderAngle) * 0.03;
            
            // Social fish tend to swim towards others
            if (this.socialTendency > 0.7 && Math.random() < 0.05) {
                // Find center of nearby fish
                let centerX = 0;
                let centerY = 0;
                let count = 0;
                
                for (const other of fishes) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 150) {
                        centerX += other.x;
                        centerY += other.y;
                        count++;
                    }
                }
                
                if (count > 0) {
                    centerX /= count;
                    centerY /= count;
                    
                    // Adjust angle slightly towards center
                    const toCenterAngle = Math.atan2(centerY - this.y, centerX - this.x);
                    const angleDiff = toCenterAngle - this.angle;
                    this.angle += Math.sin(angleDiff) * 0.05 * this.socialTendency;
                }
            }
            
            // Normal speed
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            
            // Vary base speed occasionally
            if (Math.random() < 0.01) {
                this.speed = 0.8 + Math.random() * 1.2;
            }
        }
        
        enforceBoundaries() {
            // Hard boundaries - bounce off walls
            const margin = 20;
            if (this.x < margin) {
                this.x = margin;
                this.angle = Math.PI - this.angle;
            } else if (this.x > width - margin) {
                this.x = width - margin;
                this.angle = Math.PI - this.angle;
            }
            if (this.y < margin) {
                this.y = margin;
                this.angle = -this.angle;
            } else if (this.y > height - margin) {
                this.y = height - margin;
                this.angle = -this.angle;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // Draw vision cone if hunting
            if (!this.canMate && this.targetFood) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, this.visionRange, -this.visionAngle/2, this.visionAngle/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw scent detection indicator (pulsing nose)
                if (this.targetFood.getScentStrengthAt(this.x, this.y) > this.smellSensitivity) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    const pulseSize = 5 + Math.sin(Date.now() * 0.005) * 2;
                    ctx.beginPath();
                    ctx.arc(this.bodyWidth * 12, 0, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Special effect for displaying to potential mates
            if (this.courtingPartner) {
                switch (this.displayBehavior) {
                    case 0: // Dance display - wiggling
                        // This is handled in the courtship movement
                        break;
                    case 1: // Color flash - temporarily brighten colors
                        const intensity = 0.3 + 0.7 * Math.sin(Date.now() * 0.01 * this.displayIntensity);
                        for (let i = 0; i < 3; i++) {
                            this.bodyColor[i] = Math.min(1, this.bodyColor[i] * (1 + intensity * 0.3));
                            this.finColor[i] = Math.min(1, this.finColor[i] * (1 + intensity * 0.3));
                        }
                        break;
                    case 2: // Fin display - temporarily enlarge fins
                        const finSizeMultiplier = 1 + 0.5 * Math.sin(Date.now() * 0.01 * this.displayIntensity);
                        break;
                }
            }
            
            // Draw body
            ctx.fillStyle = `rgb(${Math.floor(this.bodyColor[0]*255)},${Math.floor(this.bodyColor[1]*255)},${Math.floor(this.bodyColor[2]*255)})`;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.bodyWidth * 15, this.bodyHeight * 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tail fin
            const displayedFinSize = this.courtingPartner && this.displayBehavior === 2 ? 
                  this.finSize * (1 + 0.5 * Math.sin(Date.now() * 0.01 * this.displayIntensity)) : 
                  this.finSize;
                  
            ctx.fillStyle = `rgb(${Math.floor(this.finColor[0]*255)},${Math.floor(this.finColor[1]*255)},${Math.floor(this.finColor[2]*255)})`;
            ctx.beginPath();
            ctx.moveTo(-this.bodyWidth * 15, 0);
            ctx.lineTo(-this.bodyWidth * 15 - displayedFinSize * 20, -displayedFinSize * 10);
            ctx.lineTo(-this.bodyWidth * 15 - displayedFinSize * 20, displayedFinSize * 10);
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes (symmetry affects eye placement)
            const eyeOffset = this.bodyHeight * 3 * this.symmetry;
            ctx.fillStyle = `rgb(${Math.floor(this.eyeColor[0]*255)},${Math.floor(this.eyeColor[1]*255)},${Math.floor(this.eyeColor[2]*255)})`;
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 5, -eyeOffset, this.eyeSize * 5, 0, Math.PI * 2);
            ctx.arc(this.bodyWidth * 5, eyeOffset, this.eyeSize * 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 5, -eyeOffset, this.eyeSize * 2, 0, Math.PI * 2);
            ctx.arc(this.bodyWidth * 5, eyeOffset, this.eyeSize * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw gender indicator (subtle)
            ctx.fillStyle = this.isFemale ? 'rgba(255, 150, 150, 0.7)' : 'rgba(150, 150, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(this.bodyWidth * 10, 0, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw "selected" indicator if this is the selected fish
            if (this === selectedFish) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.ellipse(0, 0, this.bodyWidth * 20, this.bodyHeight * 15, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.restore();
            
            // Draw additional status indicators above fish (in world coordinates)
            this.drawStatusIndicators(ctx);
        }
        
        drawStatusIndicators(ctx) {
            const indicatorY = this.y - 25;
            
            // Draw heart above courting fish
            if (this.courtingPartner) {
                ctx.save();
                ctx.translate(this.x, indicatorY);
                ctx.fillStyle = 'rgba(255, 105, 180, 0.8)';
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.bezierCurveTo(-5, -10, -10, -5, -10, 0);
                ctx.bezierCurveTo(-10, 5, -5, 10, 0, 15);
                ctx.bezierCurveTo(5, 10, 10, 5, 10, 0);
                ctx.bezierCurveTo(10, -5, 5, -10, 0, -5);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw food bar for fish
            if (this.foodPoints > 0) {
                ctx.save();
                ctx.translate(this.x, this.y + 15);
                
                // Background bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-15, 0, 30, 3);
                
                // Food bar
                const foodBarWidth = Math.min(30, (this.foodPoints / 40) * 30);
                ctx.fillStyle = this.foodPoints >= 10 ? '#00ff00' : '#ffff00';
                ctx.fillRect(-15, 0, foodBarWidth, 3);
                
                ctx.restore();
            }
            
            // Draw learning indicator for fish that just learned something
            if (this.memory.observations.length > 0 && Math.random() < 0.01) {
                ctx.save();
                ctx.translate(this.x, indicatorY - 15);
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw light rays
                const rayLength = 5 + Math.sin(Date.now() * 0.01) * 2;
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 5, Math.sin(angle) * 5);
                    ctx.lineTo(Math.cos(angle) * (5 + rayLength), Math.sin(angle) * (5 + rayLength));
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
    }

    let fishes = [];
    let eggs = [];
    let foodPellets = [];
    let generation = 0;
    let totalEggsThisGeneration = 0;
    let totalFoodThisGeneration = 0;

    class FoodPellet {
        constructor() {
            this.x = Math.random() * (width - 40) + 20;
            this.y = Math.random() * (height - 40) + 20;
            this.value = 5; // Each pellet is worth 5 points
            this.radius = 3;
            this.scentStrength = 1.0; // How strong the scent is at the source
            this.scentDecayRate = 0.02; // How quickly scent fades with distance
        }

        draw(ctx) {
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        getScentStrengthAt(x, y) {
            const dx = x - this.x;
            const dy = y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // Scent strength decreases exponentially with distance
            return this.scentStrength * Math.exp(-distance * this.scentDecayRate);
        }
    }

    function createInitialGeneration() {
        fishes = [];
        eggs = [];
        foodPellets = [];
        totalEggsThisGeneration = 0;
        totalFoodThisGeneration = 0;
        generation = 0;
        
        // Create first generation - 6 fish (3 males, 3 females)
        for (let i = 0; i < 6; i++) {
            const fish = new Fish();
            fish.isFemale = i < 3; // First 3 are females
            
            // Assign distinct colors to make it easier to identify them
            const hue = (i / 6) * 360;
            const [r, g, b] = hslToRgb(hue / 360, 0.7, 0.5);
            fish.bodyColor = [r, g, b];
            
            // Spread them out in the tank
            const angle = (i / 6) * Math.PI * 2;
            const radius = Math.min(width, height) * 0.3;
            fish.x = width / 2 + Math.cos(angle) * radius;
            fish.y = height / 2 + Math.sin(angle) * radius;
            
            // First generation starts with food
            fish.foodPoints = 10;
            fish.canMate = true;
            
            fishes.push(fish);
        }
        
        // No food for first generation since they start fed
    }
    
    function hslToRgb(h, s, l) {
        let r, g, b;
        
        if (s === 0) {
            r = g = b = l; // Achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        
        return [r, g, b];
    }

    function spawnFood() {
        // Spawn food pellets worth foodPerGeneration points total
        const targetFood = CONFIG.foodPerGeneration;
        while (totalFoodThisGeneration < targetFood) {
            foodPellets.push(new FoodPellet());
            totalFoodThisGeneration += 5;
        }
    }

    function findMate(fish) {
        if (fish.cooldown > 0) return null;
        
        // Must have eaten at least 10 food to mate
        if (!fish.canMate) return null;
        
        // Increase searching time and lower standards gradually
        fish.searchingTime++;
        if (fish.searchingTime > 200) { // Lowered from 300
            fish.attractionThreshold *= 0.99; // Lower standards faster
        }
        
        if (fish.isFemale) {
            // Females only pursue males they find very attractive and who can mate
            let bestMale = null;
            let highestScore = -Infinity;
            
            for (const other of fishes) {
                if (!other.isFemale && other.cooldown === 0 && !other.courtingPartner && other.canMate) {
                    const score = fish.evaluateBeauty(other);
                    if (score > highestScore && score >= fish.attractionThreshold) {
                        highestScore = score;
                        bestMale = other;
                    }
                }
            }
            
            // Only pursue if male is sufficiently attractive
            if (bestMale) {
                // Check if other females are also interested
                let competitors = 0;
                for (const otherFemale of fishes) {
                    if (otherFemale !== fish && otherFemale.isFemale && !otherFemale.courtingPartner && otherFemale.canMate) {
                        const otherScore = otherFemale.evaluateBeauty(bestMale);
                        if (otherScore >= otherFemale.attractionThreshold) {
                            competitors++;
                        }
                    }
                }
                
                // If too much competition, might not pursue
                if (competitors > 1 && Math.random() < 0.3) {
                    return null;
                }
            }
            
            return bestMale;
        } else {
            // Males pursue any female they find attractive enough who can mate
            let bestFemale = null;
            let highestScore = -Infinity;
            
            for (const other of fishes) {
                if (other.isFemale && other.cooldown === 0 && !other.courtingPartner && other.canMate) {
                    const score = fish.evaluateBeauty(other);
                    if (score > highestScore && score >= fish.attractionThreshold * 0.5) {
                        highestScore = score;
                        bestFemale = other;
                    }
                }
            }
            
            return bestFemale;
        }
        
        return null;
    }

    function performCourtship(fish) {
        const partner = fish.courtingPartner;
        fish.courtingTime++;
        
        // Calculate center point between the two fish
        const centerX = (fish.x + partner.x) / 2;
        const centerY = (fish.y + partner.y) / 2;
        
        // Different courtship movements based on display behavior
        let radius = 15;
        let speed = 0.05;
        
        switch (fish.displayBehavior) {
            case 0: // Dance pattern - figure 8
                fish.dancePhase += speed * fish.displayIntensity;
                const pattern = Math.sin(fish.dancePhase * 2);
                const offset = fish.isFemale ? 0 : Math.PI;
                fish.x = centerX + Math.cos(fish.dancePhase + offset) * radius * (1 + 0.3 * pattern);
                fish.y = centerY + Math.sin(fish.dancePhase + offset) * radius;
                break;
                
            case 1: // Color flash - subtle movement in place
                fish.dancePhase += speed * 0.7;
                fish.x = centerX + (fish.isFemale ? -1 : 1) * radius * 0.7;
                fish.y = centerY + Math.sin(fish.dancePhase) * radius * 0.3;
                break;
                
            case 2: // Fin display - circling
                fish.dancePhase += speed * fish.displayIntensity;
                const circleOffset = fish.isFemale ? 0 : Math.PI;
                fish.x = centerX + Math.cos(fish.dancePhase + circleOffset) * radius;
                fish.y = centerY + Math.sin(fish.dancePhase + circleOffset) * radius;
                break;
        }
        
        // Face each other
        fish.angle = Math.atan2(partner.y - fish.y, partner.x - fish.x);
        
        // After 10 seconds (600 frames at 60fps), check if mating succeeds
        if (fish.courtingTime > 600) {
            const maxEggs = CONFIG.maxFishCount / 2; // Half the max fish count can be eggs
            
            if (fish.isFemale && totalEggsThisGeneration < maxEggs) {
                // First generation always mates successfully
                let matingSuccess = false;
                if (generation === 0) {
                    matingSuccess = true;
                } else {
                    // Mating success depends on beauty score and breeding success trait
                    const finalAttraction = fish.evaluateBeauty(partner);
                    const breedingSuccessChance = (fish.breedingSuccess + partner.breedingSuccess) / 2;
                    matingSuccess = finalAttraction > (fish.attractionThreshold * 0.8) && 
                                   Math.random() < breedingSuccessChance;
                }
                
                if (matingSuccess) {
                    // Female accepts and lays egg
                    eggs.push({
                        x: fish.x,
                        y: fish.y,
                        hatchTime: 0,
                        maxHatchTime: 180,
                        parents: [fish, partner]
                    });
                    
                    // Update breeding stats
                    fish.eggsLaid++;
                    fish.hasMated = true;
                    partner.hasMated = true;
                    totalEggsThisGeneration++;
                    
                    // Learn from successful mating
                    fish.learn({
                        partnerId: partner.id,
                        attractiveness: fish.evaluateBeauty(partner),
                        displayBehavior: partner.displayBehavior
                    }, 'successfulMates');
                    
                    partner.learn({
                        partnerId: fish.id,
                        attractiveness: partner.evaluateBeauty(fish),
                        displayBehavior: fish.displayBehavior
                    }, 'successfulMates');
                    
                    // Shorter cooldown to allow for multiple matings
                    fish.cooldown = 120;
                    partner.cooldown = 60; // Male has shorter cooldown
                    
                    // Reset attraction threshold for next mating
                    fish.attractionThreshold = 1.5;
                    fish.searchingTime = 0;
                } else {
                    // Female rejects after courtship
                    fish.cooldown = 60; // Can try again sooner
                    partner.cooldown = 15; // Male recovers quickly from rejection
                }
            }
            
            // End courtship regardless of outcome
            fish.searchingTime = 0;
            partner.searchingTime = 0;
            fish.courtingPartner = null;
            partner.courtingPartner = null;
        }
    }

    function update() {
        if (paused) return;
        
        // Update all fish
        for (const fish of fishes) {
            if (fish.courtingPartner) {
                // If courting, perform mating dance
                performCourtship(fish);
            } else {
                // Normal swimming and eating
                fish.update();
            }
            
            // Look for mates only if able
            const maxEggs = CONFIG.maxFishCount / 2;
            if (totalEggsThisGeneration < maxEggs && !fish.courtingPartner && fish.canMate) {
                const mate = findMate(fish);
                
                if (mate && !mate.courtingPartner) {
                    // Start courtship
                    fish.courtingPartner = mate;
                    mate.courtingPartner = fish;
                    fish.courtingTime = 0;
                    mate.courtingTime = 0;
                }
            }
        }
        
        // Update eggs
        for (let i = eggs.length - 1; i >= 0; i--) {
            const egg = eggs[i];
            egg.hatchTime++;
            
            if (egg.hatchTime >= egg.maxHatchTime) {
                // Check if we've reached the maximum number of eggs
                const maxEggs = CONFIG.maxFishCount / 2;
                
                if (totalEggsThisGeneration >= maxEggs || generation === 0) {
                    // Move to the next generation
                    fishes = [];
                    generation++;
                    
                    // Hatch all eggs at once
                    for (let j = 0; j < eggs.length; j++) {
                        const newFish = new Fish(eggs[j].parents);
                        // Ensure balanced gender distribution
                        newFish.isFemale = j < eggs.length / 2;
                        newFish.x = eggs[j].x + (Math.random() - 0.5) * 50;
                        newFish.y = eggs[j].y + (Math.random() - 0.5) * 50;
                        fishes.push(newFish);
                    }
                    
                    eggs = [];
                    totalEggsThisGeneration = 0;
                    
                    // Spawn food for new generation
                    totalFoodThisGeneration = 0;
                    foodPellets = [];
                    spawnFood();
                    
                    // Update UI to show we've moved to a new generation
                    updateStats();
                    
                    break;
                } else {
                    // Just hatch this individual egg
                    const newFish = new Fish(egg.parents);
                    // Alternate genders for balance
                    newFish.isFemale = fishes.filter(f => f.isFemale).length < fishes.length / 2;
                    newFish.x = egg.x + (Math.random() - 0.5) * 50;
                    newFish.y = egg.y + (Math.random() - 0.5) * 50;
                    fishes.push(newFish);
                    
                    // Remove the hatched egg
                    eggs.splice(i, 1);
                }
            }
        }
        
        // Spawn more food if needed (always keep at least 3 food pellets available)
        if (foodPellets.length < 3 && totalFoodThisGeneration < CONFIG.foodPerGeneration) {
            foodPellets.push(new FoodPellet());
            totalFoodThisGeneration += 5;
        }
        
        // Occasionally update stats display (not every frame to save performance)
        if (Math.random() < 0.01) {
            updateStats();
        }
    }

    function draw() {
        // Draw dark deep blue background
        ctx.fillStyle = "#000522";
        ctx.fillRect(0, 0, width, height);
        
        // Draw aquarium edges
        ctx.strokeStyle = "#003366";
        ctx.lineWidth = 3;
        ctx.strokeRect(10, 10, width - 20, height - 20);
        
        // Draw food pellets with scent clouds
        for (const food of foodPellets) {
            // Draw scent cloud
            const gradient = ctx.createRadialGradient(food.x, food.y, 0, food.x, food.y, 100);
            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(food.x, food.y, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw food pellet
            food.draw(ctx);
        }
        
        // Draw eggs
        for (const egg of eggs) {
            const progress = egg.hatchTime / egg.maxHatchTime;
            ctx.fillStyle = `rgba(255, 255, 150, ${0.7 + progress * 0.3})`;
            ctx.beginPath();
            ctx.arc(egg.x, egg.y, 5 + progress * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Egg glow
            ctx.strokeStyle = `rgba(255, 255, 200, ${0.3 - progress * 0.3})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Draw fish
        for (const fish of fishes) {
            fish.draw(ctx);
        }
        
        // Draw beauty visualization for selected fish
        if (selectedFish) {
            drawBeautyVisualization(selectedFish);
        }
        
        // Draw "Paused" indicator if simulation is paused
        if (paused) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', width / 2, height / 2);
            ctx.textAlign = 'left';
        }
    }
    
    function drawBeautyVisualization(fish) {
        // Only show visualization for a selected fish
        const beautyViz = document.getElementById('beauty-visualization');
        beautyViz.style.left = fish.x + 'px';
        beautyViz.style.top = (fish.y - 100) + 'px';
        beautyViz.style.opacity = '1';
        
        // Show preferences for other fish
        if (showFishDetails) {
            const otherFish = fishes.filter(f => f !== fish);
            if (otherFish.length > 0) {
                // Find the most and least attractive fish
                let mostAttractive = otherFish[0];
                let leastAttractive = otherFish[0];
                let highestScore = fish.evaluateBeauty(mostAttractive);
                let lowestScore = highestScore;
                
                for (const other of otherFish) {
                    const score = fish.evaluateBeauty(other);
                    if (score > highestScore) {
                        highestScore = score;
                        mostAttractive = other;
                    }
                    if (score < lowestScore) {
                        lowestScore = score;
                        leastAttractive = other;
                    }
                }
                
                // Position the beauty pointer according to current fish's threshold
                const pointer = document.getElementById('beauty-pointer');
                const thresholdPercentage = (fish.attractionThreshold - 1) / 3 * 100;
                pointer.style.left = `${thresholdPercentage}%`;
            }
        } else {
            // Hide visualization if not showing details
            beautyViz.style.opacity = '0';
        }
    }
    
    function updateStats() {
        const statsDiv = document.getElementById('stats');
        
        // Basic stats
        let statsHTML = `
            <p>Generation: ${generation}</p>
            <p>Population: ${fishes.length} fish</p>
            <p>Eggs: ${totalEggsThisGeneration}/${CONFIG.maxFishCount/2}</p>
            <p>Food available: ${foodPellets.length * 5}/${CONFIG.foodPerGeneration}</p>
        `;
        
        // Evolutionary trends
        if (fishes.length > 0) {
            // Calculate average stats
            let avgSymmetry = 0;
            let avgEyeSize = 0;
            let avgFinSize = 0;
            let avgVisionRange = 0;
            let avgSmellSensitivity = 0;
            
            for (const fish of fishes) {
                avgSymmetry += fish.symmetry;
                avgEyeSize += fish.eyeSize;
                avgFinSize += fish.finSize;
                avgVisionRange += fish.visionRange;
                avgSmellSensitivity += fish.smellSensitivity;
            }
            
            avgSymmetry /= fishes.length;
            avgEyeSize /= fishes.length;
            avgFinSize /= fishes.length;
            avgVisionRange /= fishes.length;
            avgSmellSensitivity /= fishes.length;
            
            statsHTML += `
                <p><strong>Evolution Trends:</strong></p>
                <p>Avg Symmetry: ${avgSymmetry.toFixed(2)}</p>
                <p>Avg Eye Size: ${avgEyeSize.toFixed(2)}</p>
                <p>Avg Fin Size: ${avgFinSize.toFixed(2)}</p>
                <p>Avg Vision: ${avgVisionRange.toFixed(2)}</p>
                <p>Avg Smell: ${avgSmellSensitivity.toFixed(3)}</p>
            `;
        }
        
        statsDiv.innerHTML = statsHTML;
    }

    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }
    
    function togglePause() {
        paused = !paused;
        document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        document.getElementById('control-panel').style.display = paused ? 'block' : 'none';
    }
    
    function initializeControls() {
        // Pause/resume button
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        
        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            generation = 0;
            createInitialGeneration();
            if (paused) togglePause();
        });
        
        // Control panel sliders
        const sliders = document.querySelectorAll('#control-panel input[type="range"]');
        sliders.forEach(slider => {
            slider.addEventListener('input', function() {
                document.getElementById(`${this.id}Value`).textContent = this.value;
            });
        });
        
        // Apply button
        document.getElementById('applyBtn').addEventListener('click', () => {
            // Update configuration with slider values
            CONFIG.mutationRate = parseFloat(document.getElementById('mutationRate').value);
            CONFIG.beautyEvolutionRate = parseFloat(document.getElementById('beautyEvolutionRate').value);
            CONFIG.maxFishCount = parseInt(document.getElementById('fishCount').value);
            CONFIG.foodPerGeneration = parseInt(document.getElementById('foodPerGeneration').value);
            CONFIG.learningRate = parseFloat(document.getElementById('learningRate').value);
            
            // Resume simulation
            togglePause();
        });
        
        // Canvas click handler for selecting fish
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check if clicked on a fish
            let clickedFish = null;
            for (const fish of fishes) {
                const dx = fish.x - clickX;
                const dy = fish.y - clickY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Use fish size for more accurate click detection
                const fishSize = Math.max(fish.bodyWidth, fish.bodyHeight) * 15;
                if (dist < fishSize) {
                    clickedFish = fish;
                    break;
                }
            }
            
            // Select the clicked fish or deselect if clicked on the same fish again
            if (clickedFish) {
                if (selectedFish === clickedFish) {
                    selectedFish = null;
                    document.getElementById('beauty-visualization').style.opacity = '0';
                } else {
                    selectedFish = clickedFish;
                    showFishDetails = true;
                }
            } else {
                selectedFish = null;
                document.getElementById('beauty-visualization').style.opacity = '0';
            }
        });
        
        // Key press for toggling fish detail view
        document.addEventListener('keydown', (event) => {
            if (event.key === 'd' || event.key === 'D') {
                showFishDetails = !showFishDetails;
            }
        });
    }

    window.addEventListener("resize", () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    });

    createInitialGeneration();
    initializeControls();
    spawnFood();
    updateStats();
    animate();
</script>
</body>
</html>
