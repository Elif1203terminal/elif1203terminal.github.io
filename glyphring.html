<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Stone Rings Puzzle</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/TextureLoader.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.1.1/src/bold/style.css"/>
    <style>
        body {
            font-family: 'Cinzel Decorative', serif;
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: #d0c7b3;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .button {
            padding: 12px 24px;
            border: 2px solid #8a7653;
            border-radius: 8px;
            background-color: rgba(50, 40, 30, 0.8);
            color: #d0c7b3;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-family: 'Cinzel Decorative', serif;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6), inset 0 1px 3px rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .button:hover {
            background-color: rgba(80, 60, 40, 0.9);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.8), inset 0 2px 5px rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        .button:active {
            background-color: rgba(40, 30, 20, 0.9);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6), inset 0 1px 2px rgba(0, 0, 0, 0.3);
            transform: translateY(1px);
        }
        
        #message {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(20, 15, 10, 0.85);
            color: #d0c7b3;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 1.2rem;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            pointer-events: none;
            border: 1px solid #8a7653;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.8);
            text-align: center;
            max-width: 80%;
            letter-spacing: 1px;
        }
        #message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }

        .title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #d0c7b3;
            font-size: 2rem;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.9);
            z-index: 5;
            font-family: 'Cinzel Decorative', serif;
            letter-spacing: 2px;
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }
        .loading-text {
            color: #d0c7b3;
            font-size: 1.5rem;
            margin-top: 20px;
            letter-spacing: 3px;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(138, 118, 83, 0.3);
            border-radius: 50%;
            border-top-color: #8a7653;
            animation: spin 1.5s linear infinite;
        }
        
        .ring-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(20, 15, 10, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #8a7653;
            font-size: 0.9rem;
            z-index: 10;
        }
        .instruction {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(20, 15, 10, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #8a7653;
            font-size: 0.9rem;
            text-align: center;
            z-index: 10;
            max-width: 80%;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .reset-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border: 2px solid #8a7653;
            border-radius: 8px;
            background-color: rgba(50, 40, 30, 0.8);
            color: #d0c7b3;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-family: 'Cinzel Decorative', serif;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }
        .reset-button:hover {
            background-color: rgba(80, 60, 40, 0.9);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.8);
        }

        /* Media queries for responsiveness */
        @media (max-width: 768px) {
            .controls {
                top: unset;
                bottom: 90px;
            }
            
            .title {
                font-size: 1.5rem;
            }
            
            .instruction {
                top: 80px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader"></div>
        <div class="loading-text">DECIPHERING ANCIENT STONES...</div>
    </div>

    <div class="title">The Ancient Stone Rings of SOLV</div>
    
    <div class="instruction">
        Click on a ring to select it, then use the buttons to rotate.<br>
        Align all rings to reveal the ancient carved glyph.
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        <button id="rotateLeft" class="button">
            <i class="ph-bold ph-arrow-fat-left"></i> Rotate Left
        </button>
        <button id="rotateRight" class="button">
            Rotate Right <i class="ph-bold ph-arrow-fat-right"></i>
        </button>
    </div>

    <div id="message"></div>
    <div class="ring-info" id="ringInfo">Selected: Outer Ring</div>
    <button id="resetButton" class="reset-button">Reset Puzzle</button>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas, 
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(0x111111);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 7;

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x443322, 0.5);
        scene.add(ambientLight);

        // Add directional light with shadows for dramatic lighting
        const directionalLight = new THREE.DirectionalLight(0xffeecc, 1.0);
        directionalLight.position.set(3, 5, 7);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);
        // Add dramatic side lights to highlight the carvings
        const leftLight = new THREE.PointLight(0xb58d4c, 1.2, 20);
        leftLight.position.set(-3, 2, 5);
        scene.add(leftLight);

        // Add blue-ish backlight for depth and contrast
        const backLight = new THREE.PointLight(0x8ba3b9, 0.6, 20);
        backLight.position.set(2, -2, -3);
        scene.add(backLight);

        // Add fog for atmospheric depth
        scene.fog = new THREE.FogExp2(0x111111, 0.03);

        // Orbit Controls with better constraints
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 5;
        controls.maxDistance = 15;
        controls.maxPolarAngle = Math.PI / 1.5; // Limit vertical rotation
        const rotateLeftButton = document.getElementById('rotateLeft');
        const rotateRightButton = document.getElementById('rotateRight');
        const messageElement = document.getElementById('message');
        const ringInfoElement = document.getElementById('ringInfo');
        const resetButton = document.getElementById('resetButton');
        const loadingScreen = document.getElementById('loadingScreen');

        let selectedRingIndex = 0;
        let rings = [];
        const ringRadius = 2.5;
        const ringThickness = 0.32; // Slightly thicker rings
        const numberOfRings = 7;
        const glyphText = "SOLV";
        let isSolved = false;
        let animationFrameId;
        
        // Ring names for UI display
        const ringNames = [
            "Outer Ring", 
            "Second Ring", 
            "Third Ring", 
            "Fourth Ring", 
            "Fifth Ring", 
            "Sixth Ring", 
            "Inner Ring"
        ];
        // Load better stone textures with more visible patterns
        const textureLoader = new THREE.TextureLoader();
        const stoneTexture = textureLoader.load('https://i.imgur.com/XNrEoRv.jpg', function() {
            const normalMap = textureLoader.load('https://i.imgur.com/jvnQwN9.jpg', function() {
                const roughnessMap = textureLoader.load('https://i.imgur.com/n2r6LZP.jpg', function() {
                    const aoMap = textureLoader.load('https://i.imgur.com/9MRfLy0.jpg', function() {
                        // All textures loaded, hide loading screen
                        setTimeout(() => {
                            loadingScreen.style.opacity = 0;
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                        }, 1500); // Add slight delay for effect
                        createRings(stoneTexture, normalMap, roughnessMap, aoMap);
                        animate();
                    });
                });
            });
        });
        // Custom shader for the rings with dramatically improved glyph effect
        function createRingMaterial(stoneTexture, normalMap, roughnessMap, aoMap, ringIndex) {
            // Define more dramatic glyph colors (darker for better carving effect)
            const glyphColors = [
                new THREE.Color(0x080808), // Almost black for deeper carving effect
                new THREE.Color(0x0c0a08),
                new THREE.Color(0x0e0c0a),
                new THREE.Color(0x0a0806),
                new THREE.Color(0x090705),
                new THREE.Color(0x080604),
                new THREE.Color(0x070503)  // Dark inner carving
            ];
            
            // Define better stone colors with more variation
            const ringColors = [
                new THREE.Color(0xd6c7b8), // Lighter outer ring
                new THREE.Color(0xcdbfb0),
                new THREE.Color(0xc4b6a7),
                new THREE.Color(0xbead9e),
                new THREE.Color(0xb8a695),
                new THREE.Color(0xb29f8d),
                new THREE.Color(0xab9884)  // Darker inner ring
            ];
            return new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    varying float vRingRadius;
                    varying float vRingThickness;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;

                    void main() {
                        vPosition = position;
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vRingRadius = ${ringRadius.toFixed(2)};
                        vRingThickness = ${ringThickness.toFixed(2)};
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    varying float vRingRadius;
                    varying float vRingThickness;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    
                    uniform float uRotation;
                    uniform int uIndex;
                    uniform int uSelectedRingIndex;
                    uniform vec3 uGlyphColor;
                    uniform vec3 uRingColor;
                    uniform sampler2D uStoneTexture;
                    uniform sampler2D uNormalMap;
                    uniform sampler2D uRoughnessMap;
                    uniform sampler2D uAOMap;
                    uniform float uTime;
                    uniform vec3 uLightPos;
                    // Improved hash function for better noise
                    float hash(vec2 p) {
                        p = fract(p * vec2(123.34, 456.21));
                        p += dot(p, p + 45.32);
                        return fract(p.x * p.y);
                    }
                    
                    // Better noise function for stone detail
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        
                        // Quintic interpolation for smoother transitions
                        vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
                        
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        
                        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                    }

                    // Fractal noise for better stone texture
                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        
                        // Add multiple layers of noise with different frequencies
                        for (int i = 0; i < 5; i++) {
                            value += amplitude * noise(p * frequency);
                            amplitude *= 0.5;
                            frequency *= 2.0;
                        }
                        
                        return value;
                    }
                        // Dramatically improved S glyph with deeper carving
                    float getS(vec2 uv, float scale) {
                        uv *= scale;
                        float d = 1000.0; // Initialize with a large value
                        
                        // Define the S shape with smoother, more defined curves
                        // Top curve
                        float topCurve = length(uv - vec2(-0.05, 0.5)) - 0.25;
                        d = min(d, topCurve);
                        
                        // Bottom curve
                        float bottomCurve = length(uv - vec2(0.05, -0.5)) - 0.25;
                        d = min(d, bottomCurve);
                        
                        // Middle curve
                        float middleCurve = length(uv - vec2(0.0, 0.0)) - 0.2;
                        d = min(d, middleCurve);
                        
                        // Connecting segments
                        float topConnect = length(uv - vec2(0.15, 0.25)) - 0.1;
                        float bottomConnect = length(uv - vec2(-0.15, -0.25)) - 0.1;
                        d = min(d, topConnect);
                        d = min(d, bottomConnect);
                        
                        // Create a smoother, deeper carving effect
                        float carved = smoothstep(0.01, -0.05, d);
                        
                        // Add noise to edges for weathered look
                        float edgeNoise = noise(uv * 50.0) * 0.03;
                        carved = max(0.0, carved - edgeNoise);
                        
                        return carved;
                    }
                        // Improved O glyph with realistic carving
                    float getO(vec2 uv, float scale) {
                        uv *= scale;
                        float r = length(uv);
                        
                        // Create a thicker, more visible ring
                        float innerRadius = 0.3;
                        float outerRadius = 0.5;
                        
                        // Smoother transition for carved effect
                        float carved = smoothstep(innerRadius + 0.01, innerRadius - 0.05, r) - 
                                       smoothstep(outerRadius - 0.01, outerRadius + 0.05, r);
                        
                        // Add weathered details to the edges
                        float edgeNoise = noise(uv * 60.0) * 0.04;
                        carved = max(0.0, carved - edgeNoise * (1.0 - abs(r - ((innerRadius + outerRadius) * 0.5)) * 4.0));
                        
                        return carved;
                    }
                    
                    // Improved L glyph with better carving
                    float getL(vec2 uv, float scale) {
                        uv *= scale;
                        float d = 1000.0;
                        
                        // Vertical stem of the L
                        float vLine = length(vec2(uv.x + 0.3, max(0.0, uv.y))) - 0.18;
                        d = min(d, vLine);
                        
                        // Horizontal base of the L
                        float hLine = length(vec2(min(0.0, uv.x + 0.2), uv.y + 0.5)) - 0.18;
                        d = min(d, hLine);
                        
                        // Corner of the L needs special handling for smoother carving
                        float corner = length(vec2(uv.x + 0.3, uv.y + 0.5)) - 0.18;
                        d = min(d, corner);
                        
                        // Create deeper carved effect
                        float carved = smoothstep(0.02, -0.05, d);
                        
                        // Add weathering to edges
                        float edgeNoise = noise(uv * 55.0) * 0.03;
                        carved = max(0.0, carved - edgeNoise * smoothstep(-0.1, 0.1, d));
                        
                        return carved;
                    }
                    // Improved V glyph with better carving and definition
                    float getV(vec2 uv, float scale) {
                        uv *= scale;
                        
                        // Create two lines meeting at a point
                        float leftLine = abs(uv.x + uv.y * 0.9) - 0.08;
                        float rightLine = abs(uv.x - uv.y * 0.9) - 0.08;
                        
                        // Keep only the portions above a certain y value for the V shape
                        leftLine = max(leftLine, uv.y + 0.7);
                        rightLine = max(rightLine, uv.y + 0.7);
                        
                        // Combine the two lines
                        float d = min(leftLine, rightLine);
                        
                        // Create deeper carved effect
                        float carved = smoothstep(0.02, -0.05, d);
                        
                        // Add weathering to edges
                        float edgeNoise = noise(uv * 65.0) * 0.04;
                        carved = max(0.0, carved - edgeNoise * smoothstep(-0.1, 0.1, d));
                        
                        return carved;
                    }

                    void main() {
                        // Calculate radial coordinates with better mapping for the stone texture
                        vec2 radialUV = vec2(
                            atan(vPosition.y, vPosition.x) / (2.0 * 3.14159) + 0.5,
                            0.5 + vPosition.z / vRingThickness * 0.25
                        );
                        // Apply multiple layers of stone texture detail
                        vec3 stoneColor = texture2D(uStoneTexture, radialUV * 2.0).rgb;
                        float roughness = texture2D(uRoughnessMap, radialUV * 3.0).r;
                        float ao = texture2D(uAOMap, radialUV * 2.5).r;
                        
                        // Enhanced aging and weathering effects
                        float stoneFbm = fbm(radialUV * 15.0);
                        float weathering = fbm(radialUV * 30.0 + vec2(uTime * 0.01, stoneFbm));
                        
                        // Adjust stone color with weathering and dirt patterns
                        stoneColor *= mix(0.85, 1.1, stoneFbm);
                        stoneColor *= mix(0.9, 1.0, weathering);
                        
                        // Add realistic stone variations with cracks and imperfections
                        float crackPattern = smoothstep(0.6, 0.8, fbm(radialUV * 20.0 + vec2(weathering)));
                        stoneColor *= mix(0.9, 1.05, crackPattern);
                        
                        // Base color with better stone color blending
                        vec3 baseColor = stoneColor * uRingColor;
                        
                        // Account for ambient occlusion in stone color
                        baseColor *= mix(0.8, 1.0, ao);
                        // Normalize position for glyph calculation
                        vec2 normPos = normalize(vPosition.xy);
                        
                        // Rotate the UV for the glyph based on ring rotation
                        float angle = uRotation;
                        vec2 rotatedUV = vec2(
                            normPos.x * cos(angle) - normPos.y * sin(angle),
                            normPos.x * sin(angle) + normPos.y * cos(angle)
                        );
                        
                        // Select the appropriate glyph based on ring index with better distribution
                        float glyphValue = 0.0;
                        
                        // Distribute glyphs across rings with clearer carving
                        if (uIndex == 0) {
                            glyphValue = getS(rotatedUV, 2.0); // S on the outer ring
                        } else if (uIndex == 1) {
                            glyphValue = getO(rotatedUV, 1.8); // O on the second ring
                        } else if (uIndex == 2) {
                            glyphValue = getL(rotatedUV, 1.9); // L on the third ring
                        } else if (uIndex == 3) {
                            glyphValue = getV(rotatedUV, 1.8); // V on the fourth ring
                        } else if (uIndex == 4) {
                            glyphValue = getS(rotatedUV, 1.5) * 0.9; // Fainter repetition on inner rings
                        } else if (uIndex == 5) {
                            glyphValue = getO(rotatedUV, 1.4) * 0.8;
                        } else if (uIndex == 6) {
                            glyphValue = getL(rotatedUV, 1.3) * 0.7;
                        }
                            // Create a deeply carved glyph effect with realistic depth and shadows
                        // Darker shadow inside the carving
                        vec3 glyphShadowColor = vec3(0.05, 0.04, 0.03);
                        
                        // Factor in ambient occlusion for deeper carving appearance
                        float carvingDepth = glyphValue * (0.85 + roughness * 0.3);
                        
                        // Add grime buildup in the carvings
                        vec3 grimeDarkColor = vec3(0.08, 0.05, 0.03);
                        vec3 carvingColor = mix(glyphShadowColor, grimeDarkColor, weathering * roughness);
                        
                        // Mix the stone color with the carving color based on the glyph value
                        vec3 finalColor = mix(baseColor, carvingColor, carvingDepth);
                        
                        // Add lighting effects to enhance the 3D appearance of carvings
                        // Calculate lighting direction for each point on the surface
                        vec3 lightDir = normalize(uLightPos - vWorldPosition);
                        float diffuseLighting = max(0.1, dot(vNormal, lightDir));
                        // Create enhanced shadows and highlights for the carvings
                        float highlightIntensity = smoothstep(0.8, 1.0, glyphValue) * smoothstep(0.7, 0.5, diffuseLighting);
                        float shadowIntensity = smoothstep(0.4, 0.7, glyphValue) * smoothstep(0.5, 0.2, diffuseLighting);
                        
                        // Apply dramatic lighting to the carvings
                        finalColor = mix(finalColor, glyphShadowColor * 0.7, shadowIntensity * 0.6);
                        
                        // Add dirt and moss buildup in crevices and carved areas
                        float creviceEffect = glyphValue * roughness * (1.0 - diffuseLighting) * 0.8;
                        vec3 mossColor = vec3(0.15, 0.23, 0.08);
                        vec3 dirtColor = vec3(0.25, 0.20, 0.15);
                        finalColor = mix(finalColor, mix(dirtColor, mossColor, weathering), creviceEffect * weathering);
                        
                        // Add general lighting to the whole surface
                        finalColor *= 0.6 + diffuseLighting * 0.5;
                        
                        // Apply weathering effects to the surface
                        float stoneEdgeWear = smoothstep(0.4, 0.6, fbm(radialUV * 20.0)) * 0.15;
                        finalColor = mix(finalColor, baseColor * 0.7, stoneEdgeWear * (1.0 - glyphValue));
                        // Selection highlight with pulsing effect
                        if (uSelectedRingIndex == uIndex) {
                            float pulse = 0.6 + 0.4 * sin(uTime * 2.5);
                            vec3 highlightColor = vec3(1.0, 0.9, 0.7) * pulse;
                            finalColor = mix(finalColor, highlightColor, 0.3);
                        }
                        
                        // Enhance lighting for selected ring
                        if (uSelectedRingIndex == uIndex) {
                            finalColor *= 1.2;
                        }
                        
                        // Color adjustments
                        finalColor = pow(finalColor, vec3(1.0/2.2)); // Gamma correction
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                uniforms: {
                    uRotation: { value: 0.0 },
                    uIndex: { value: ringIndex },
                    uSelectedRingIndex: { value: 0 }, // Start with the outer ring selected
                   uGlyphColor: { value: glyphColors[ringIndex] },
                   uRingColor: { value: ringColors[ringIndex] },
                   uStoneTexture: { value: stoneTexture },
                   uNormalMap: { value: normalMap },
                   uRoughnessMap: { value: roughnessMap },
                   uAOMap: { value: aoMap },
                   uTime: { value: 0.0 },
                   uLightPos: { value: new THREE.Vector3(5, 5, 5) }
               },
           });
       }
       // Create the rings with enhanced texture and depth
       function createRings(stoneTexture, normalMap, roughnessMap, aoMap) {
            for (let i = 0; i < numberOfRings; i++) {
                const geometry = new THREE.TorusGeometry(
                    ringRadius - (i * ringThickness * 1.2), 
                    ringThickness, 
                    96,  // Higher segment count for smoother rings
                    128
                );
                
                const material = createRingMaterial(stoneTexture, normalMap, roughnessMap, aoMap, i);
                const ring = new THREE.Mesh(geometry, material);
                
                ring.rotation.x = Math.PI / 2; // Face forward
                
                // Randomize initial rotation for puzzle start - substantial randomization
                const randomRotation = Math.random() * Math.PI * 2;
                ring.userData = { 
                    rotationOffset: randomRotation, 
                    initialRotation: randomRotation,
                    targetRotation: randomRotation 
                };
                ring.material.uniforms.uRotation.value = randomRotation;
                
                // Add subtle random positioning to make the rings look more ancient/less perfect
                ring.position.set(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.03
                );
                
                scene.add(ring);
                rings.push(ring);
            }
            
            // Set the initial selected ring
            if (rings.length > 0) {
                rings[0].material.uniforms.uSelectedRingIndex.value = 0;
                updateRingInfo(0);
            }
            
            // Show initial message about the puzzle being scrambled
            showMessage("Ancient glyphs scattered across the rings... Can you restore them?");
        }
        // Function to handle rotation with smooth animation
        function rotateRing(index, direction) {
            if (isSolved) return;

            const ring = rings[index];
            const rotationStep = Math.PI / 8; // 22.5 degrees
            
            // Set the target rotation
            ring.userData.targetRotation = ring.userData.rotationOffset + (direction * rotationStep);
            
            // Add a subtle vibration effect for stone grinding
            ring.position.x += (Math.random() - 0.5) * 0.08;
            ring.position.y += (Math.random() - 0.5) * 0.08;
            
            // Slight z-axis movement for depth feel
            ring.position.z += (Math.random() - 0.5) * 0.04;
        }

        // Update ring info display
        function updateRingInfo(index) {
            ringInfoElement.textContent = `Selected: ${ringNames[index]}`;
        }
        // Function to check if the puzzle is solved with improved tolerance
        function checkForSolution() {
            const tolerance = 0.15; // Slightly more forgiving tolerance
            
            // Check if all rings are aligned to zero rotation (modulo 2π)
            for (let i = 0; i < rings.length; i++) {
                const ring = rings[i];
                const currentRotation = ring.userData.rotationOffset % (2 * Math.PI);
                const normalizedRotation = currentRotation < 0 ? currentRotation + (2 * Math.PI) : currentRotation;
                
                if (normalizedRotation > tolerance && normalizedRotation < (2 * Math.PI - tolerance)) {
                    return false;
                }
            }
            
            // If we got here, the puzzle is solved
            isSolved = true;
            showMessage("Ancient Secret Revealed! The Carved Glyphs Align...");
            
            // Victory effects
            celebrateSolution();
        }
        // Function to celebrate solving the puzzle with enhanced effects
        function celebrateSolution() {
            // Add dramatic glow effect to the rings
            rings.forEach((ring, index) => {
                const glowIntensity = 0.2 + (rings.length - index) * 0.15;
                
                // Create golden hue in the carvings for victory effect
                const goldGlyphColor = new THREE.Color(0.9 + glowIntensity * 0.2, 
                                                     0.8 + glowIntensity * 0.15, 
                                                     0.5 + glowIntensity * 0.1);
                ring.material.uniforms.uGlyphColor.value = goldGlyphColor;
                
                // Animate to aligned position with a slight delay based on ring index
                setTimeout(() => {
                    // Center the rings perfectly
                    ring.position.set(0, 0, 0);
                }, index * 100);
            });
            
            // Add a point light in the center that pulses with golden light
            const victoryLight = new THREE.PointLight(0xffd700, 2, 15);
            victoryLight.position.set(0, 0, 2);
            scene.add(victoryLight);
            
            // Add subtle rays of light from the center
            const victoryBackLight = new THREE.PointLight(0xffffcc, 1.5, 12);
            victoryBackLight.position.set(0, 0, -3);
            scene.add(victoryBackLight);
            
            // Animate the victory lights
            function pulseLight() {
                const time = Date.now() * 0.001;
                victoryLight.intensity = 1.5 + Math.sin(time * 3) * 0.8;
                victoryBackLight.intensity = 1.2 + Math.sin(time * 2.5 + 1) * 0.5;
                
                if (isSolved) {
                    requestAnimationFrame(pulseLight);
                }
            }
            
            pulseLight();
        }
        // Function to display a message
        function showMessage(text) {
            messageElement.textContent = text;
            messageElement.classList.add('show');
            
            // Keep victory message visible forever, clear other messages after delay
            if (!text.includes("Ancient Secret Revealed")) {
                setTimeout(() => {
                    messageElement.classList.remove('show');
                }, 3500);
            }
        }

        // Function to reset the puzzle
        function resetPuzzle() {
            isSolved = false;
            
            // Hide the victory message if showing
            messageElement.classList.remove('show');
            
            // Randomize all ring rotations
            rings.forEach(ring => {
                const randomRotation = Math.random() * Math.PI * 2;
                ring.userData.rotationOffset = randomRotation;
                ring.userData.targetRotation = randomRotation;
                ring.material.uniforms.uRotation.value = randomRotation;
                // Reset any special effects
                const ringIndex = rings.indexOf(ring);
                const glyphColors = [
                    new THREE.Color(0x080808),
                    new THREE.Color(0x0c0a08),
                    new THREE.Color(0x0e0c0a),
                    new THREE.Color(0x0a0806),
                    new THREE.Color(0x090705),
                    new THREE.Color(0x080604),
                    new THREE.Color(0x070503)
                ];
                ring.material.uniforms.uGlyphColor.value = glyphColors[ringIndex];
                
                // Add subtle random positioning for ancient look
                ring.position.set(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.03
                );
            });
            
            // Show reset message
            showMessage("Puzzle Reset - Ancient Glyphs Scattered Once More!");
            
            // Remove any victory lights
            scene.children.forEach(child => {
                if (child.type === "PointLight" && 
                    child !== leftLight && 
                    child !== backLight && 
                    child !== directionalLight && 
                    child !== ambientLight) {
                    scene.remove(child);
                }
            });
            
            // Restart animation if it was stopped
            if (!animationFrameId) {
                animate();
            }
        }
        // Set up event listeners
        rotateLeftButton.addEventListener('click', () => {
            rotateRing(selectedRingIndex, -1); // Negative for counterclockwise
        });

        rotateRightButton.addEventListener('click', () => {
            rotateRing(selectedRingIndex, 1); // Positive for clockwise
        });
        
        resetButton.addEventListener('click', resetPuzzle);

        // Event listener for ring selection via mouse/touch with improved selection
        canvas.addEventListener('click', (event) => {
            if (isSolved) return; // Disable selection when solved
            
            // Calculate mouse position in normalized device coordinates
            const rect = canvas.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            // Find intersections with rings
            const intersects = raycaster.intersectObjects(rings);
            
            if (intersects.length > 0) {
                // Update selected ring
                const newIndex = rings.indexOf(intersects[0].object);
                // Reset highlighting on all rings
                rings.forEach((ring) => {
                    ring.material.uniforms.uSelectedRingIndex.value = -1;
                });
                
                // Highlight newly selected ring
                selectedRingIndex = newIndex;
                rings[selectedRingIndex].material.uniforms.uSelectedRingIndex.value = selectedRingIndex;
                
                // Update UI
                updateRingInfo(selectedRingIndex);
                
                // Selection effect - slight pop and glow
                const ring = rings[selectedRingIndex];
                ring.scale.set(1.03, 1.03, 1.03);
                setTimeout(() => {
                    ring.scale.set(1, 1, 1);
                }, 200);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
        });
        // Keyboard controls with improved responsiveness
        window.addEventListener('keydown', (event) => {
            if (isSolved) return;
            
            switch (event.key) {
                case 'ArrowLeft':
                    rotateRing(selectedRingIndex, -1);
                    break;
                case 'ArrowRight':
                    rotateRing(selectedRingIndex, 1);
                    break;
                case 'ArrowUp':
                    // Select previous ring (towards center)
                    const prevIndex = (selectedRingIndex + 1) % numberOfRings;
                    
                    // Reset highlighting
                    rings.forEach((ring) => {
                        ring.material.uniforms.uSelectedRingIndex.value = -1;
                    });
                    
                    // Update selection
                    selectedRingIndex = prevIndex;
                    rings[selectedRingIndex].material.uniforms.uSelectedRingIndex.value = selectedRingIndex;
                    updateRingInfo(selectedRingIndex);
                    break;
                    case 'ArrowDown':
                    // Select next ring (towards outer)
                    const nextIndex = (selectedRingIndex - 1 + numberOfRings) % numberOfRings;
                    
                    // Reset highlighting
                    rings.forEach((ring) => {
                        ring.material.uniforms.uSelectedRingIndex.value = -1;
                    });
                    
                    // Update selection
                    selectedRingIndex = nextIndex;
                    rings[selectedRingIndex].material.uniforms.uSelectedRingIndex.value = selectedRingIndex;
                    updateRingInfo(selectedRingIndex);
                    break;
                case 'r':
                    resetPuzzle();
                    break;
            }
        });

        // Animation function with improved effects
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            // Update shader time uniform for animations
            const time = performance.now() * 0.001; // Convert to seconds
            rings.forEach(ring => {
                // Update time uniform for all rings
                ring.material.uniforms.uTime.value = time;
                
                // Smooth rotation animation towards target
                if (ring.userData.rotationOffset !== ring.userData.targetRotation) {
                    const diff = ring.userData.targetRotation - ring.userData.rotationOffset;
                    ring.userData.rotationOffset += diff * 0.12; // Ease towards target
                    
                    // Update shader rotation
                    ring.material.uniforms.uRotation.value = ring.userData.rotationOffset;
                    
                    // When close enough, snap to exact target to prevent floating point issues
                    if (Math.abs(diff) < 0.01) {
                        ring.userData.rotationOffset = ring.userData.targetRotation;
                        ring.material.uniforms.uRotation.value = ring.userData.rotationOffset;
                        
                        // Check if puzzle is solved after a rotation completes
                        checkForSolution();
                    }
                }
                
                // Gradually return rings to center position (from vibration effect)
                ring.position.x *= 0.92;
                ring.position.y *= 0.92;
                ring.position.z *= 0.92;
                
                // Add subtle breathing effect for non-selected rings when not solved
                if (!isSolved && ring.material.uniforms.uSelectedRingIndex.value === -1) {
                    const breathEffect = Math.sin(time * 0.5 + rings.indexOf(ring)) * 0.0005;
                    ring.position.z += breathEffect;
                }
            });
            // Create subtle camera sway for more dynamic feel
            if (!isSolved) {
                camera.position.x = Math.sin(time * 0.2) * 0.3;
                camera.position.y = Math.cos(time * 0.3) * 0.2;
            } else {
                // Slowly orbit around the solved rings for dramatic effect
                const orbitRadius = 7;
                const orbitSpeed = 0.2;
                camera.position.x = Math.sin(time * orbitSpeed) * orbitRadius;
                camera.position.z = Math.cos(time * orbitSpeed) * orbitRadius;
                camera.lookAt(0, 0, 0);
            }
            
            // Update controls
            controls.update();
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // Handle initial sizing
        function initialResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
        }

        // Initialize size
        initialResize();
    </script>
</body>
</html>
