<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>True Mathematical Fractals</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            border: none;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.5s ease;
            color: white;
            font-size: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
        }
        
        #start-button svg {
            width: 48px;
            height: 48px;
            margin-bottom: 10px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
        }
        #restart-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
        }
        
        .control-button {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            color: white;
            padding: 8px 16px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        #fractal-info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            display: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            display: none;
            text-align: center;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #fractal-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
        }
        
        #fractal-selector select {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <button id="start-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19V5M5 12l7-7 7 7"/>
        </svg>
        Click Me
    </button>
    
    <div id="fractal-info"></div>
    <div id="loading">Rendering fractal <span class="spinner"></span></div>
    
    <div id="fractal-selector">
        <select id="fractal-type">
            <option value="mandelbrot">Mandelbrot Set</option>
            <option value="julia">Julia Set</option>
            <option value="burningship">Burning Ship Fractal</option>
            <option value="tricorn">Tricorn Fractal</option>
        </select>
    </div>
    
    <div id="controls">
        <button id="pause-button" class="control-button">Pause</button>
        <button id="save-jpg-button" class="control-button">Save JPG</button>
        <button id="zoom-in-button" class="control-button">Zoom In</button>
        <button id="zoom-out-button" class="control-button">Zoom Out</button>
    </div>
    <div id="restart-container">
        <button id="restart-button" class="control-button">Restart</button>
    </div>

    <script>
        // Initialize canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Animation variables
        let isDrawing = false;
        let isPaused = false;
        let animationFrameId = null;
        let startTime = 0;
        
        // Drawing state
        let currentX = 0;
        let currentY = 0;
        let targetX = 0;
        let targetY = 0;
        let arrowAngle = 0;
        let drawSpeed = 0.05;
        let currentPixel = 0;
        let maxPixel = 0;
        // Fractal state
        let fractalType = 'mandelbrot';
        let fractalData = [];
        let colorPalette = [];
        let zoomLevel = 1;
        
        // Complex plane boundaries
        let xMin = -2.5;
        let xMax = 1.5;
        let yMin = -1.5;
        let yMax = 1.5;
        
        // Julia set parameters
        let juliaC = { x: -0.7, y: 0.27 }; // Initial interesting value
        
        // Controls
        const startButton = document.getElementById('start-button');
        const controls = document.getElementById('controls');
        const pauseButton = document.getElementById('pause-button');
        const saveJpgButton = document.getElementById('save-jpg-button');
        const restartContainer = document.getElementById('restart-container');
        const restartButton = document.getElementById('restart-button');
        const fractalInfo = document.getElementById('fractal-info');
        const loadingElement = document.getElementById('loading');
        const fractalSelector = document.getElementById('fractal-selector');
        const fractalTypeSelect = document.getElementById('fractal-type');
        const zoomInButton = document.getElementById('zoom-in-button');
        const zoomOutButton = document.getElementById('zoom-out-button');
        
        // Generate a color palette
        function generateColorPalette(numColors) {
            const palette = [];
            for (let i = 0; i < numColors; i++) {
                const hue = (i / numColors) * 360;
                palette.push(`hsl(${hue}, 100%, 50%)`);
            }
            return palette;
        }
        // Color mapping functions
        function mapColor(iterations, maxIterations) {
            if (iterations === maxIterations) return '#000000'; // Black for the set itself
            
            // Advanced coloring using normalized iterations
            const normalized = iterations + 1 - Math.log(Math.log(2)) / Math.log(2);
            const hue = (normalized * 10) % 360;
            const saturation = 100;
            const lightness = 50;
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        // Fractal computation functions
        function computeMandelbrot(cx, cy, maxIterations) {
            let x = 0;
            let y = 0;
            let iteration = 0;
            
            while (x*x + y*y <= 4 && iteration < maxIterations) {
                const xTemp = x*x - y*y + cx;
                y = 2*x*y + cy;
                x = xTemp;
                iteration++;
            }
            
            return iteration;
        }
        
        function computeJulia(zx, zy, cx, cy, maxIterations) {
            let x = zx;
            let y = zy;
            let iteration = 0;
            
            while (x*x + y*y <= 4 && iteration < maxIterations) {
                const xTemp = x*x - y*y + cx;
                y = 2*x*y + cy;
                x = xTemp;
                iteration++;
            }
            
            return iteration;
        }
        function computeBurningShip(cx, cy, maxIterations) {
            let x = 0;
            let y = 0;
            let iteration = 0;
            
            while (x*x + y*y <= 4 && iteration < maxIterations) {
                const xTemp = x*x - y*y + cx;
                y = Math.abs(2*x*y) + cy;
                x = xTemp;
                iteration++;
            }
            
            return iteration;
        }
        
        function computeTricorn(cx, cy, maxIterations) {
            let x = 0;
            let y = 0;
            let iteration = 0;
            
            while (x*x + y*y <= 4 && iteration < maxIterations) {
                const xTemp = x*x - y*y + cx;
                y = -2*x*y + cy;
                x = xTemp;
                iteration++;
            }
            
            return iteration;
        }
        
        // Generate fractal data
        function generateFractalData() {
            const maxIterations = 100;
            const pixelData = [];
            const width = canvas.width;
            const height = canvas.height;
            
            // Calculate aspect ratio to preserve fractal shape
            const aspectRatio = width / height;
            let yRange = yMax - yMin;
            xMin = -2.5 / zoomLevel;
            xMax = 1.5 / zoomLevel;
            yMin = -1.5 / zoomLevel;
            yMax = 1.5 / zoomLevel;
            // Adjust for different fractal types
            if (fractalType === 'julia') {
                xMin = -2 / zoomLevel;
                xMax = 2 / zoomLevel;
                yMin = -1.5 / zoomLevel;
                yMax = 1.5 / zoomLevel;
            }
            
            // Create coordinate path for drawing animation
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    
                    // Map pixel coordinates to complex plane
                    const cx = xMin + (x / width) * (xMax - xMin);
                    const cy = yMin + (y / height) * (yMax - yMin);
                    
                    // Compute fractal value based on type
                    let iterations;
                    
                    switch (fractalType) {
                        case 'mandelbrot':
                            iterations = computeMandelbrot(cx, cy, maxIterations);
                            break;
                        case 'julia':
                            iterations = computeJulia(cx, cy, juliaC.x, juliaC.y, maxIterations);
                            break;
                        case 'burningship':
                            iterations = computeBurningShip(cx, cy, maxIterations);
                            break;
                        case 'tricorn':
                            iterations = computeTricorn(cx, cy, maxIterations);
                            break;
                        default:
                            iterations = computeMandelbrot(cx, cy, maxIterations);
                    }
                    
                    // Store data for animation
                    pixelData.push({
                        x: x,
                        y: y,
                        iterations: iterations,
                        color: mapColor(iterations, maxIterations)
                    });
                }
            }
            return pixelData;
        }
        
        // Create an offscreen buffer for the fractal image
        function renderFullFractal() {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = canvas.width;
            offCanvas.height = canvas.height;
            const offCtx = offCanvas.getContext('2d');
            
            // Create image data object
            const imageData = offCtx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            // Fill image data with fractal colors
            for (let i = 0; i < fractalData.length; i++) {
                const pixel = fractalData[i];
                const color = pixel.color;
                
                // Convert HSL to RGB
                const rgbColor = hslToRgb(color);
                
                // Set pixel data
                const index = (pixel.y * canvas.width + pixel.x) * 4;
                data[index] = rgbColor[0];     // R
                data[index + 1] = rgbColor[1]; // G
                data[index + 2] = rgbColor[2]; // B
                data[index + 3] = 255;         // A
            }
            
            // Put the image data on the offscreen canvas
            offCtx.putImageData(imageData, 0, 0);
            
            return offCanvas;
        }
        
        // Convert HSL color to RGB
        function hslToRgb(hslColor) {
            // Parse HSL color string
            const hslMatch = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!hslMatch) return [0, 0, 0]; // Default black if parsing fails
            
            const h = parseInt(hslMatch[1]) / 360;
            const s = parseInt(hslMatch[2]) / 100;
            const l = parseInt(hslMatch[3]) / 100;
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        // Draw single point with smooth curve
        function drawArrow(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            // Draw the arrow
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(0, 0);
            ctx.lineTo(-10, 5);
            ctx.stroke();
            
            ctx.restore();
        }
        // Animation loop for revealing the fractal
        function animate() {
            if (!isDrawing || isPaused) return;
            
            if (currentPixel === 0) {
                // Generate full fractal image at the start
                const fractalImage = renderFullFractal();
                
                // Start drawing the fractal
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw the full image with low opacity
                ctx.globalAlpha = 0.1;
                ctx.drawImage(fractalImage, 0, 0);
                ctx.globalAlpha = 1.0;
            }
            
            // Draw pixels in batches for smoother animation
            const batchSize = Math.ceil(fractalData.length / 100);
            const endPixel = Math.min(currentPixel + batchSize, fractalData.length);
            
            for (let i = currentPixel; i < endPixel; i++) {
                const pixel = fractalData[i];
                
                // Set current target
                targetX = pixel.x;
                targetY = pixel.y;
                
                // Calculate arrow position
                const dx = targetX - currentX;
                const dy = targetY - currentY;
                arrowAngle = Math.atan2(dy, dx);
                
                // Move toward target
                currentX += dx * drawSpeed;
                currentY += dy * drawSpeed;
                
                // Draw pixel
                ctx.fillStyle = pixel.color;
                ctx.fillRect(pixel.x, pixel.y, 1, 1);
            }
            
            // Draw the arrow at current position
            drawArrow(currentX, currentY, arrowAngle);
            
            // Update progress
            currentPixel = endPixel;
            
            // Continue or finish
            if (currentPixel < fractalData.length) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                // Drawing complete
                fractalInfo.textContent = `${getFractalName(fractalType)} (Complete)`;
            }
        }
        // Get human-readable fractal name
        function getFractalName(type) {
            switch (type) {
                case 'mandelbrot': return 'Mandelbrot Set';
                case 'julia': return 'Julia Set';
                case 'burningship': return 'Burning Ship Fractal';
                case 'tricorn': return 'Tricorn Fractal';
                default: return 'Fractal';
            }
        }
        
        // Initialize the animation
        function initAnimation() {
            // Hide start button
            startButton.style.opacity = '0';
            setTimeout(() => {
                startButton.style.display = 'none';
            }, 500);
            
            // Show loading and info
            loadingElement.style.display = 'block';
            fractalInfo.textContent = `Calculating ${getFractalName(fractalType)}...`;
            fractalInfo.style.display = 'block';
            
            // Show controls
            controls.style.display = 'block';
            restartContainer.style.display = 'block';
            fractalSelector.style.display = 'block';
            
            // Generate fractal data in a separate thread to avoid blocking UI
            setTimeout(() => {
                try {
                    // Reset state
                    currentPixel = 0;
                    isDrawing = true;
                    isPaused = false;
                    
                    // Generate new fractal data
                    fractalData = generateFractalData();
                    maxPixel = fractalData.length;
                    
                    // Set starting position
                    if (fractalData.length > 0) {
                        currentX = fractalData[0].x;
                        currentY = fractalData[0].y;
                    }
                    // Update fractal info
                    fractalInfo.textContent = `Drawing ${getFractalName(fractalType)}...`;
                    
                    // Hide loading
                    loadingElement.style.display = 'none';
                    
                    // Start animation
                    animationFrameId = requestAnimationFrame(animate);
                } catch (e) {
                    console.error("Error initializing animation:", e);
                    fractalInfo.textContent = `Error: ${e.message}`;
                    loadingElement.style.display = 'none';
                }
            }, 100);
        }
        
        // Event listeners
        startButton.addEventListener('click', () => {
            initAnimation();
        });
        
        canvas.addEventListener('click', (e) => {
            // Only respond to canvas clicks if we haven't started yet
            if (!isDrawing) {
                initAnimation();
            }
        });
        
        pauseButton.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            
            if (!isPaused) {
                // Resume animation
                animationFrameId = requestAnimationFrame(animate);
            }
        });
        
        restartButton.addEventListener('click', () => {
            // Cancel any ongoing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Reset animation state
            isDrawing = false;
            isPaused = false;
            // Update UI
            pauseButton.textContent = 'Pause';
            
            // Clear the canvas and restart
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            zoomLevel = 1; // Reset zoom
            initAnimation();
        });
        
        fractalTypeSelect.addEventListener('change', (e) => {
            fractalType = e.target.value;
            
            // If already drawing, restart with new fractal
            if (isDrawing) {
                // Cancel any ongoing animation
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                
                // Reset animation state
                isDrawing = false;
                isPaused = false;
                zoomLevel = 1; // Reset zoom
                
                // Clear the canvas and restart
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                initAnimation();
            }
        });
        
        saveJpgButton.addEventListener('click', () => {
            // Create a download link
            const link = document.createElement('a');
            link.download = `${fractalType}-fractal.jpg`;
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
        });
        
        zoomInButton.addEventListener('click', () => {
            zoomLevel *= 2;
            restartWithCurrentFractal();
        });
        
        zoomOutButton.addEventListener('click', () => {
            zoomLevel = Math.max(1, zoomLevel / 2);
            restartWithCurrentFractal();
        });
        function restartWithCurrentFractal() {
            // Cancel any ongoing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Reset animation state but keep fractal type and zoom
            isDrawing = false;
            isPaused = false;
            
            // Clear the canvas and restart
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            initAnimation();
        }
        
        // Draw a welcome message on the canvas
        function drawWelcomeMessage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('True Mathematical Fractal Explorer', canvas.width / 2, canvas.height / 2 - 40);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '16px Arial';
            ctx.fillText('Click the arrow to begin', canvas.width / 2, canvas.height / 2 + 40);
            
            ctx.fillText('Mandelbrot, Julia, Burning Ship, and Tricorn fractals', canvas.width / 2, canvas.height / 2 + 70);
        }
        
        // Initialize color palette
        colorPalette = generateColorPalette(100);
        
        // Call welcome message on load
        drawWelcomeMessage();
    </script>
</body>
</html>
