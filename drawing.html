<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Face Line Art</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
        
        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            border: none;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.5s ease;
            color: white;
            font-size: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
        }
        
        #start-button svg {
            width: 48px;
            height: 48px;
            margin-bottom: 10px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
        }
        
        #restart-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
        }
        
        .control-button {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            color: white;
            padding: 8px 16px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <button id="start-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19V5M5 12l7-7 7 7"/>
        </svg>
        Click Me
    </button>
    
    <div id="info"></div>
    
    <div id="controls">
        <button id="pause-button" class="control-button">Pause</button>
        <button id="save-jpg-button" class="control-button">Save JPG</button>
    </div>
    
    <div id="restart-container">
        <button id="restart-button" class="control-button">Restart</button>
    </div>
    <script>
        // Initialize canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Animation variables
        let isDrawing = false;
        let isPaused = false;
        let animationFrameId = null;
        
        // Drawing state
        let pathPoints = [];
        let currentPathIndex = 0;
        let currentDrawPosition = { x: 0, y: 0 };
        let targetDrawPosition = { x: 0, y: 0 };
        let drawSpeed = 0.03; // Speed at which the pen moves (0-1)
        let arrowAngle = 0;
        let facesDrawn = 0;
        
        // Controls
        const startButton = document.getElementById('start-button');
        const controls = document.getElementById('controls');
        const pauseButton = document.getElementById('pause-button');
        const saveJpgButton = document.getElementById('save-jpg-button');
        const restartContainer = document.getElementById('restart-container');
        const restartButton = document.getElementById('restart-button');
        const infoElement = document.getElementById('info');
        
        // Array to store the path that has been drawn
        let drawnPath = [];
        // Color utilities
        function getColor(progress) {
            // Convert progress to hue (0-360)
            const hue = Math.floor(progress * 360) % 360;
            return `hsl(${hue}, 100%, 60%)`;
        }
        
        // Make sure the drawing is confined to the window dimensions
        function constrainToWindow(x, y) {
            const padding = 20;
            return {
                x: Math.max(padding, Math.min(canvas.width - padding, x)),
                y: Math.max(padding, Math.min(canvas.height - padding, y))
            };
        }
        
        // Simple circle drawing helper
        function drawCircle(points, x, y, radius, segments) {
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const pointX = x + Math.cos(angle) * radius;
                const pointY = y + Math.sin(angle) * radius;
                points.push({ x: pointX, y: pointY });
            }
            return points;
        }
        
        // Generate face path
        function generateFace(centerX, centerY, size) {
            const points = [];
            
            // Face outline (oval shape)
            const faceWidth = size;
            const faceHeight = size * 1.3;
            
            // Draw face outline
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * faceWidth/2;
                const y = centerY + Math.sin(angle) * faceHeight/2;
                points.push({ x, y });
            }
            // Add eyes
            const eyeSpacing = size * 0.25;
            const eyeY = centerY - size * 0.1;
            const eyeSize = size * 0.1;
            
            // Left eye
            drawCircle(points, centerX - eyeSpacing, eyeY, eyeSize, 15);
            
            // Right eye
            drawCircle(points, centerX + eyeSpacing, eyeY, eyeSize, 15);
            
            // Nose - simple triangle
            points.push({ x: centerX, y: eyeY + size * 0.15 });  // top
            points.push({ x: centerX - size * 0.08, y: eyeY + size * 0.3 });  // left
            points.push({ x: centerX + size * 0.08, y: eyeY + size * 0.3 });  // right
            points.push({ x: centerX, y: eyeY + size * 0.15 });  // back to top
            
            // Mouth - simple curve
            const mouthY = centerY + size * 0.2;
            const mouthWidth = size * 0.3;
            
            // Mouth points
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const x = centerX - mouthWidth/2 + mouthWidth * t;
                // Smile curve
                const y = mouthY - Math.sin(Math.PI * t) * (size * 0.05);
                points.push({ x, y });
            }
            
            return points;
        }
        
        // Generate multiple faces arranged in a grid
        function generateFacesPath() {
            // Number of faces
            const numFaces = 5;
            
            // Create a grid layout
            const gridCols = 3;
            const gridRows = 2;
            
            const cellWidth = canvas.width / gridCols;
            const cellHeight = canvas.height / gridRows;
            const faceSize = Math.min(cellWidth, cellHeight) * 0.5;
            let allPoints = [];
            
            // Generate faces in a grid
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    // Skip some positions to avoid having too many faces
                    if (row * gridCols + col >= numFaces) continue;
                    
                    // Calculate center position with some randomness
                    const centerX = col * cellWidth + cellWidth/2 + (Math.random() * 0.2 - 0.1) * cellWidth;
                    const centerY = row * cellHeight + cellHeight/2 + (Math.random() * 0.2 - 0.1) * cellHeight;
                    
                    // Generate a face at this position
                    const facePoints = generateFace(centerX, centerY, faceSize);
                    
                    // If this isn't the first face, add a connecting line
                    if (allPoints.length > 0) {
                        const lastPoint = allPoints[allPoints.length - 1];
                        // Simple straight line to connect faces
                        const firstPoint = facePoints[0];
                        
                        // Create a smooth connection with a few points
                        const steps = 5;
                        for (let s = 1; s <= steps; s++) {
                            const t = s / steps;
                            const x = lastPoint.x + (firstPoint.x - lastPoint.x) * t;
                            const y = lastPoint.y + (firstPoint.y - lastPoint.y) * t;
                            allPoints.push({ x, y });
                        }
                    }
                    
                    // Add this face's points to the combined path
                    allPoints = allPoints.concat(facePoints);
                }
            }
            
            return allPoints;
        }
        // Draw the arrow
        function drawArrow(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            // Draw the arrow
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(0, 0);
            ctx.lineTo(-10, 5);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Draw the path that has been drawn so far
        function drawPath() {
            if (drawnPath.length < 2) return;
            
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw line segments with colors
            for (let i = 1; i < drawnPath.length; i++) {
                const point = drawnPath[i];
                const prevPoint = drawnPath[i - 1];
                
                // Get color based on progress through the drawing
                const progress = i / pathPoints.length;
                ctx.strokeStyle = getColor(progress);
                
                ctx.beginPath();
                ctx.moveTo(prevPoint.x, prevPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
        }
        // Main animation loop
        function animate() {
            if (!isDrawing || isPaused) return;
            
            // If we have points to draw
            if (pathPoints.length > 0) {
                // Get the target point
                if (currentPathIndex < pathPoints.length) {
                    targetDrawPosition = pathPoints[currentPathIndex];
                    
                    // Calculate distance to target
                    const dx = targetDrawPosition.x - currentDrawPosition.x;
                    const dy = targetDrawPosition.y - currentDrawPosition.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // If we're close enough to the target, move to the next point
                    if (distance < 2) {
                        currentPathIndex++;
                    } else {
                        // Move toward the target (easing for smooth animation)
                        const easingFactor = Math.min(drawSpeed * (60 / (1000 / 16)), 1);
                        currentDrawPosition.x += dx * easingFactor;
                        currentDrawPosition.y += dy * easingFactor;
                        
                        // Ensure we never go off screen
                        const constrained = constrainToWindow(currentDrawPosition.x, currentDrawPosition.y);
                        currentDrawPosition.x = constrained.x;
                        currentDrawPosition.y = constrained.y;
                        
                        // Calculate angle for arrow
                        arrowAngle = Math.atan2(dy, dx);
                        
                        // Add the current position to the drawn path
                        drawnPath.push({ x: currentDrawPosition.x, y: currentDrawPosition.y });
                    }
                } else {
                    // We've completed the drawing
                    infoElement.textContent = `Completed! 5 faces drawn`;
                }
            }
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the path and the arrow
            drawPath();
            drawArrow(currentDrawPosition.x, currentDrawPosition.y, arrowAngle);
            
            // Continue the animation
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Initialize the animation
        function initAnimation() {
            // Hide start button
            startButton.style.opacity = '0';
            setTimeout(() => {
                startButton.style.display = 'none';
            }, 500);
            
            // Show controls and info
            controls.style.display = 'block';
            restartContainer.style.display = 'block';
            infoElement.style.display = 'block';
            infoElement.textContent = "Drawing line art faces...";
            
            // Reset animation state
            isDrawing = true;
            isPaused = false;
            drawnPath = [];
            currentPathIndex = 0;
            
            // Generate faces path
            pathPoints = generateFacesPath();
            facesDrawn = 5;
            
            // Set starting position to the first point
            if (pathPoints.length > 0) {
                currentDrawPosition = { ...pathPoints[0] };
                drawnPath.push({ ...currentDrawPosition });
                currentPathIndex = 1;
                
                // Start the animation
                animationFrameId = requestAnimationFrame(animate);
            } else {
                infoElement.textContent = "Error: Failed to generate face path";
            }
        }
        // Event listeners
        startButton.addEventListener('click', function() {
            initAnimation();
        });
        
        canvas.addEventListener('click', function(e) {
            // Only respond to canvas clicks if we haven't started yet
            if (!isDrawing && e.target === canvas) {
                initAnimation();
            }
        });
        
        pauseButton.addEventListener('click', function() {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            
            if (!isPaused) {
                // Resume animation
                animationFrameId = requestAnimationFrame(animate);
            }
        });
        
        restartButton.addEventListener('click', function() {
            // Cancel any ongoing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Reset animation state
            isDrawing = false;
            isPaused = false;
            
            // Update UI
            pauseButton.textContent = 'Pause';
            
            // Clear the canvas and restart
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            initAnimation();
        });
        saveJpgButton.addEventListener('click', function() {
            // Create a download link
            const link = document.createElement('a');
            link.download = 'face-line-art.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.8);
            link.click();
        });
        
        // Draw a welcome message on the canvas
        function drawWelcomeMessage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Fluid Face Line Art', canvas.width / 2, canvas.height / 2 - 40);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '16px Arial';
            ctx.fillText('Click the arrow to begin drawing beautiful line art faces', canvas.width / 2, canvas.height / 2 + 40);
        }
        
        // Call welcome message on load
        drawWelcomeMessage();
    </script>
</body>
</html>
